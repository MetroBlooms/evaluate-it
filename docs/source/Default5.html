<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-viewport-Default'>/**
</span> * @private
 * Base class for iOS and Android viewports.
 */
Ext.define(&#39;Ext.viewport.Default&#39;, {
    extend: &#39;Ext.Container&#39;,

    xtype: &#39;viewport&#39;,

<span id='Ext-viewport-Default-property-PORTRAIT'>    PORTRAIT: &#39;portrait&#39;,
</span>
<span id='Ext-viewport-Default-property-LANDSCAPE'>    LANDSCAPE: &#39;landscape&#39;,
</span>
    requires: [
        &#39;Ext.LoadMask&#39;,
        &#39;Ext.layout.Card&#39;,
        &#39;Ext.util.InputBlocker&#39;
    ],

<span id='Ext-viewport-Default-event-ready'>    /**
</span>     * @event ready
     * Fires when the Viewport is in the DOM and ready.
     * @param {Ext.Viewport} this
     */

<span id='Ext-viewport-Default-event-maximize'>    /**
</span>     * @event maximize
     * Fires when the Viewport is maximized.
     * @param {Ext.Viewport} this
     */

<span id='Ext-viewport-Default-event-orientationchange'>    /**
</span>     * @event orientationchange
     * Fires when the Viewport orientation has changed.
     * @param {Ext.Viewport} this
     * @param {String} newOrientation The new orientation.
     * @param {Number} width The width of the Viewport.
     * @param {Number} height The height of the Viewport.
     */

    config: {
<span id='Ext-viewport-Default-cfg-autoMaximize'>        /**
</span>         * @cfg {Boolean} autoMaximize
         * Whether or not to always automatically maximize the viewport on first load and all subsequent orientation changes.
         *
         * This is set to `false` by default for a number of reasons:
         *
         * - Orientation change performance is drastically reduced when this is enabled, on all devices.
         * - On some devices (mostly Android) this can sometimes cause issues when the default browser zoom setting is changed.
         * - When wrapping your phone in a native shell, you may get a blank screen.
         * - When bookmarked to the homescreen (iOS), you may get a blank screen.
         *
         * @accessor
         */
        autoMaximize: false,

<span id='Ext-viewport-Default-cfg-autoBlurInput'>        /**
</span>         * @private
         */
        autoBlurInput: true,

<span id='Ext-viewport-Default-cfg-preventPanning'>        /**
</span>         * @cfg {Boolean} preventPanning
         * Whether or not to always prevent default panning behavior of the
         * browser&#39;s viewport.
         * @accessor
         */
        preventPanning: true,

<span id='Ext-viewport-Default-cfg-preventZooming'>        /**
</span>         * @cfg {Boolean} preventZooming
         * `true` to attempt to stop zooming when you double tap on the screen on mobile devices,
         * typically HTC devices with HTC Sense UI.
         * @accessor
         */
        preventZooming: false,

<span id='Ext-viewport-Default-cfg-autoRender'>        /**
</span>         * @cfg
         * @private
         */
        autoRender: true,

<span id='Ext-viewport-Default-cfg-layout'>        /**
</span>         * @cfg {Object/String} layout Configuration for this Container&#39;s layout. Example:
         *
         *     Ext.create(&#39;Ext.Container&#39;, {
         *         layout: {
         *             type: &#39;hbox&#39;,
         *             align: &#39;middle&#39;
         *         },
         *         items: [
         *             {
         *                 xtype: &#39;panel&#39;,
         *                 flex: 1,
         *                 style: &#39;background-color: red;&#39;
         *             },
         *             {
         *                 xtype: &#39;panel&#39;,
         *                 flex: 2,
         *                 style: &#39;background-color: green&#39;
         *             }
         *         ]
         *     });
         *
         * See the [layouts guide](#!/guides/layouts) for more information.
         *
         * @accessor
         */
        layout: &#39;card&#39;,

<span id='Ext-viewport-Default-cfg-width'>        /**
</span>         * @cfg
         * @private
         */
        width: &#39;100%&#39;,

<span id='Ext-viewport-Default-cfg-height'>        /**
</span>         * @cfg
         * @private
         */
        height: &#39;100%&#39;,

<span id='Ext-viewport-Default-cfg-useBodyElement'>        useBodyElement: true,
</span>
<span id='Ext-viewport-Default-cfg-menus'>        /**
</span>         * An object of all the menus on this viewport.
         * @private
         */
        menus: {}
    },

<span id='Ext-viewport-Default-property-isReady'>    /**
</span>     * @property {Boolean} isReady
     * `true` if the DOM is ready.
     */
    isReady: false,

<span id='Ext-viewport-Default-property-isViewport'>    isViewport: true,
</span>
<span id='Ext-viewport-Default-property-isMaximizing'>    isMaximizing: false,
</span>
<span id='Ext-viewport-Default-cfg-id'>    id: &#39;ext-viewport&#39;,
</span>
<span id='Ext-viewport-Default-property-isInputRegex'>    isInputRegex: /^(input|textarea|select|a)$/i,
</span>
<span id='Ext-viewport-Default-property-focusedElement'>    focusedElement: null,
</span>
<span id='Ext-viewport-Default-property-fullscreenItemCls'>    /**
</span>     * @private
     */
    fullscreenItemCls: Ext.baseCSSPrefix + &#39;fullscreen&#39;,

<span id='Ext-viewport-Default-method-constructor'>    constructor: function(config) {
</span>        var bind = Ext.Function.bind;

        this.doPreventPanning = bind(this.doPreventPanning, this);
        this.doPreventZooming = bind(this.doPreventZooming, this);
        this.doBlurInput = bind(this.doBlurInput, this);

        this.maximizeOnEvents = [
          &#39;ready&#39;,
          &#39;orientationchange&#39;
        ];

      // set default devicePixelRatio if it is not explicitly defined
        window.devicePixelRatio = window.devicePixelRatio || 1;

        this.callSuper([config]);

        this.orientation = this.determineOrientation();
        this.windowWidth = this.getWindowWidth();
        this.windowHeight = this.getWindowHeight();
        this.windowOuterHeight = this.getWindowOuterHeight();

        if (!this.stretchHeights) {
        this.stretchHeights = {};
        }

        // Android is handled separately
        if (!Ext.os.is.Android || Ext.browser.is.ChromeMobile) {
            if (this.supportsOrientation()) {
                this.addWindowListener(&#39;orientationchange&#39;, bind(this.onOrientationChange, this));
            }
            else {
                this.addWindowListener(&#39;resize&#39;, bind(this.onResize, this));
            }
        }

        document.addEventListener(&#39;focus&#39;, bind(this.onElementFocus, this), true);
        document.addEventListener(&#39;blur&#39;, bind(this.onElementBlur, this), true);

        Ext.onDocumentReady(this.onDomReady, this);

        this.on(&#39;ready&#39;, this.onReady, this, {single: true});

        this.getEventDispatcher().addListener(&#39;component&#39;, &#39;*&#39;, &#39;fullscreen&#39;, &#39;onItemFullscreenChange&#39;, this);

        return this;
    },

<span id='Ext-viewport-Default-method-onDomReady'>    onDomReady: function() {
</span>        this.isReady = true;
        this.updateSize();
        this.fireEvent(&#39;ready&#39;, this);
    },

<span id='Ext-viewport-Default-method-onReady'>    onReady: function() {
</span>        if (this.getAutoRender()) {
            this.render();
        }
        if (Ext.browser.name == &#39;ChromeiOS&#39;) {
            this.setHeight(&#39;-webkit-calc(100% - &#39; + ((window.outerHeight - window.innerHeight) / 2) + &#39;px)&#39;);
        }
    },

<span id='Ext-viewport-Default-method-onElementFocus'>    onElementFocus: function(e) {
</span>        this.focusedElement = e.target;
    },

<span id='Ext-viewport-Default-method-onElementBlur'>    onElementBlur: function() {
</span>        this.focusedElement = null;
    },

<span id='Ext-viewport-Default-method-render'>    render: function() {
</span>        if (!this.rendered) {
            var body = Ext.getBody(),
                clsPrefix = Ext.baseCSSPrefix,
                classList = [],
                osEnv = Ext.os,
                osName = osEnv.name.toLowerCase(),
                browserName = Ext.browser.name.toLowerCase(),
                osMajorVersion = osEnv.version.getMajor(),
                orientation = this.getOrientation();

            this.renderTo(body);

            classList.push(clsPrefix + osEnv.deviceType.toLowerCase());

            if (osEnv.is.iPad) {
                classList.push(clsPrefix + &#39;ipad&#39;);
            }

            classList.push(clsPrefix + osName);
            classList.push(clsPrefix + browserName);

            if (osMajorVersion) {
                classList.push(clsPrefix + osName + &#39;-&#39; + osMajorVersion);
            }

            if (osEnv.is.BlackBerry) {
                classList.push(clsPrefix + &#39;bb&#39;);
            }

            if (Ext.browser.is.WebKit) {
                classList.push(clsPrefix + &#39;webkit&#39;);
            }

            if (Ext.browser.is.Standalone) {
                classList.push(clsPrefix + &#39;standalone&#39;);
            }

            if (Ext.browser.is.AndroidStock) {
                classList.push(clsPrefix + &#39;android-stock&#39;);
            }

            classList.push(clsPrefix + orientation);

            body.addCls(classList);
        }
    },

<span id='Ext-viewport-Default-method-applyAutoBlurInput'>    applyAutoBlurInput: function(autoBlurInput) {
</span>        var touchstart = (Ext.feature.has.Touch) ? &#39;touchstart&#39; : &#39;mousedown&#39;;

        if (autoBlurInput) {
            this.addWindowListener(touchstart, this.doBlurInput, false);
        }
        else {
            this.removeWindowListener(touchstart, this.doBlurInput, false);
        }

        return autoBlurInput;
    },

<span id='Ext-viewport-Default-method-applyAutoMaximize'>    applyAutoMaximize: function(autoMaximize) {
</span>        if (Ext.browser.is.WebView) {
            autoMaximize = false;
        }
        if (autoMaximize) {
            this.on(&#39;ready&#39;, &#39;doAutoMaximizeOnReady&#39;, this, { single: true });
            this.on(&#39;orientationchange&#39;, &#39;doAutoMaximizeOnOrientationChange&#39;, this);
        }
        else {
            this.un(&#39;ready&#39;, &#39;doAutoMaximizeOnReady&#39;, this);
            this.un(&#39;orientationchange&#39;, &#39;doAutoMaximizeOnOrientationChange&#39;, this);
        }

        return autoMaximize;
    },

<span id='Ext-viewport-Default-method-applyPreventPanning'>    applyPreventPanning: function(preventPanning) {
</span>        if (preventPanning) {
            this.addWindowListener(&#39;touchmove&#39;, this.doPreventPanning, false);
        }
        else {
            this.removeWindowListener(&#39;touchmove&#39;, this.doPreventPanning, false);
        }

        return preventPanning;
    },

<span id='Ext-viewport-Default-method-applyPreventZooming'>    applyPreventZooming: function(preventZooming) {
</span>        var touchstart = (Ext.feature.has.Touch) ? &#39;touchstart&#39; : &#39;mousedown&#39;;

        if (preventZooming) {
            this.addWindowListener(touchstart, this.doPreventZooming, false);
        }
        else {
            this.removeWindowListener(touchstart, this.doPreventZooming, false);
        }

        return preventZooming;
    },

<span id='Ext-viewport-Default-method-doAutoMaximizeOnReady'>    doAutoMaximizeOnReady: function() {
</span>        var controller = arguments[arguments.length - 1];

        controller.pause();

        this.isMaximizing = true;

        this.on(&#39;maximize&#39;, function() {
            this.isMaximizing = false;

            this.updateSize();

            controller.resume();

            this.fireEvent(&#39;ready&#39;, this);
        }, this, { single: true });

        this.maximize();
    },

<span id='Ext-viewport-Default-method-doAutoMaximizeOnOrientationChange'>    doAutoMaximizeOnOrientationChange: function() {
</span>        var controller = arguments[arguments.length - 1],
            firingArguments = controller.firingArguments;

        controller.pause();

        this.isMaximizing = true;

        this.on(&#39;maximize&#39;, function() {
            this.isMaximizing = false;

            this.updateSize();

            firingArguments[2] = this.windowWidth;
            firingArguments[3] = this.windowHeight;

            controller.resume();
        }, this, { single: true });

        this.maximize();
    },

<span id='Ext-viewport-Default-method-doBlurInput'>    doBlurInput: function(e) {
</span>        var target = e.target,
            focusedElement = this.focusedElement;
        //In IE9/10 browser window loses focus and becomes inactive if focused element is &lt;body&gt;. So we shouldn&#39;t call blur for &lt;body&gt;
        if (focusedElement &amp;&amp; focusedElement.nodeName.toUpperCase() != &#39;BODY&#39; &amp;&amp; !this.isInputRegex.test(target.tagName)) {
            delete this.focusedElement;
            focusedElement.blur();
        }
    },

<span id='Ext-viewport-Default-method-doPreventPanning'>    doPreventPanning: function(e) {
</span>        e.preventDefault();
    },

<span id='Ext-viewport-Default-method-doPreventZooming'>    doPreventZooming: function(e) {
</span>        // Don&#39;t prevent right mouse event
        if (&#39;button&#39; in e &amp;&amp; e.button !== 0) {
            return;
        }

        var target = e.target;

        if (target &amp;&amp; target.nodeType === 1 &amp;&amp; !this.isInputRegex.test(target.tagName)) {
            e.preventDefault();
        }
    },

<span id='Ext-viewport-Default-method-addWindowListener'>    addWindowListener: function(eventName, fn, capturing) {
</span>        window.addEventListener(eventName, fn, Boolean(capturing));
    },

<span id='Ext-viewport-Default-method-removeWindowListener'>    removeWindowListener: function(eventName, fn, capturing) {
</span>        window.removeEventListener(eventName, fn, Boolean(capturing));
    },

<span id='Ext-viewport-Default-method-doAddListener'>    doAddListener: function(eventName, fn, scope, options) {
</span>        if (eventName === &#39;ready&#39; &amp;&amp; this.isReady &amp;&amp; !this.isMaximizing) {
            fn.call(scope);
            return this;
        }

        return this.callSuper(arguments);
    },

<span id='Ext-viewport-Default-method-supportsOrientation'>    supportsOrientation: function() {
</span>        return Ext.feature.has.Orientation;
    },

<span id='Ext-viewport-Default-method-onResize'>    onResize: function() {
</span>        var oldWidth = this.windowWidth,
            oldHeight = this.windowHeight,
            width = this.getWindowWidth(),
            height = this.getWindowHeight(),
            currentOrientation = this.getOrientation(),
            newOrientation = this.determineOrientation();

        // Determine orientation change via resize. BOTH width AND height much change, otherwise
        // this is a keyboard popping up.
        if ((oldWidth !== width &amp;&amp; oldHeight !== height) &amp;&amp; currentOrientation !== newOrientation) {
            this.fireOrientationChangeEvent(newOrientation, currentOrientation);
        }
    },

<span id='Ext-viewport-Default-method-onOrientationChange'>    onOrientationChange: function() {
</span>        var currentOrientation = this.getOrientation(),
            newOrientation = this.determineOrientation();

        if (newOrientation !== currentOrientation) {
            this.fireOrientationChangeEvent(newOrientation, currentOrientation);
        }
    },

<span id='Ext-viewport-Default-method-fireOrientationChangeEvent'>    fireOrientationChangeEvent: function(newOrientation, oldOrientation) {
</span>        var clsPrefix = Ext.baseCSSPrefix;
        Ext.getBody().replaceCls(clsPrefix + oldOrientation, clsPrefix + newOrientation);

        this.orientation = newOrientation;

        this.updateSize();
        this.fireEvent(&#39;orientationchange&#39;, this, newOrientation, this.windowWidth, this.windowHeight);
    },

<span id='Ext-viewport-Default-method-updateSize'>    updateSize: function(width, height) {
</span>        this.windowWidth = width !== undefined ? width : this.getWindowWidth();
        this.windowHeight = height !== undefined ? height : this.getWindowHeight();

        return this;
    },

<span id='Ext-viewport-Default-method-waitUntil'>    waitUntil: function(condition, onSatisfied, onTimeout, delay, timeoutDuration) {
</span>        if (!delay) {
            delay = 50;
        }

        if (!timeoutDuration) {
            timeoutDuration = 2000;
        }

        var scope = this,
            elapse = 0;

        setTimeout(function repeat() {
            elapse += delay;

            if (condition.call(scope) === true) {
                if (onSatisfied) {
                    onSatisfied.call(scope);
                }
            }
            else {
                if (elapse &gt;= timeoutDuration) {
                    if (onTimeout) {
                        onTimeout.call(scope);
                    }
                }
                else {
                    setTimeout(repeat, delay);
                }
            }
        }, delay);
    },

<span id='Ext-viewport-Default-method-maximize'>    maximize: function() {
</span>        this.fireMaximizeEvent();
    },

<span id='Ext-viewport-Default-method-fireMaximizeEvent'>    fireMaximizeEvent: function() {
</span>        this.updateSize();
        this.fireEvent(&#39;maximize&#39;, this);
    },

<span id='Ext-viewport-Default-method-doSetHeight'>    doSetHeight: function(height) {
</span>        Ext.getBody().setHeight(height);

        this.callParent(arguments);
    },

<span id='Ext-viewport-Default-method-doSetWidth'>    doSetWidth: function(width) {
</span>        Ext.getBody().setWidth(width);

        this.callParent(arguments);
    },

<span id='Ext-viewport-Default-method-scrollToTop'>    scrollToTop: function() {
</span>        window.scrollTo(0, -1);
    },

<span id='Ext-viewport-Default-method-getWindowWidth'>    /**
</span>     * Retrieves the document width.
     * @return {Number} width in pixels.
     */
    getWindowWidth: function() {
        return window.innerWidth;
    },

<span id='Ext-viewport-Default-method-getWindowHeight'>    /**
</span>     * Retrieves the document height.
     * @return {Number} height in pixels.
     */
    getWindowHeight: function() {
        return window.innerHeight;
    },

<span id='Ext-viewport-Default-method-getWindowOuterHeight'>    getWindowOuterHeight: function() {
</span>        return window.outerHeight;
    },

<span id='Ext-viewport-Default-method-getWindowOrientation'>    getWindowOrientation: function() {
</span>        return window.orientation;
    },

<span id='Ext-viewport-Default-method-getOrientation'>    /**
</span>     * Returns the current orientation.
     * @return {String} `portrait` or `landscape`
     */
    getOrientation: function() {
        return this.orientation;
    },

<span id='Ext-viewport-Default-method-getSize'>    getSize: function() {
</span>        return {
            width: this.windowWidth,
            height: this.windowHeight
        };
    },

<span id='Ext-viewport-Default-method-determineOrientation'>    determineOrientation: function() {
</span>        var portrait = this.PORTRAIT,
            landscape = this.LANDSCAPE;

        if (!Ext.os.is.Android &amp;&amp; this.supportsOrientation()) {
            if (this.getWindowOrientation() % 180 === 0) {
                return portrait;
            }

            return landscape;
        }
        else {
            if (this.getWindowHeight() &gt;= this.getWindowWidth()) {
                return portrait;
            }

            return landscape;
        }
    },

<span id='Ext-viewport-Default-method-onItemFullscreenChange'>    onItemFullscreenChange: function(item) {
</span>        item.addCls(this.fullscreenItemCls);
        this.add(item);
    },

<span id='Ext-viewport-Default-method-setMenu'>    /**
</span>     * Sets a menu for a given side of the Viewport.
     *
     * Adds functionality to show the menu by swiping from the side of the screen from the given side.
     *
     * If a menu is already set for a given side, it will be removed.
     *
     * Available sides are: `left`, `right`, `top`, and `bottom`.
     *
     * @param {Ext.Menu} menu The menu to assign to the viewport
     * @param {Object} config The configuration for the menu.
     * @param {String} config.side The side to put the menu on.
     * @param {Boolean} config.cover True to cover the viewport content. Defaults to `true`.
     */
    setMenu: function(menu, config) {
        var me = this;
        config = config || {};

        // Temporary workaround for body shifting issue
        if (Ext.os.is.iOS &amp;&amp; !this.hasiOSOrientationFix) {
            this.hasiOSOrientationFix = true;
            this.on(&#39;orientationchange&#39;, function() {
                window.scrollTo(0, 0);
            }, this);
        }

        if (!menu) {
            //&lt;debug error&gt;
            Ext.Logger.error(&quot;You must specify a side to dock the menu.&quot;);
            //&lt;/debug&gt;
            return;
        }

        if (!config.side) {
            //&lt;debug error&gt;
            Ext.Logger.error(&quot;You must specify a side to dock the menu.&quot;);
            //&lt;/debug&gt;
            return;
        }

        if ([&#39;left&#39;, &#39;right&#39;, &#39;top&#39;, &#39;bottom&#39;].indexOf(config.side) == -1) {
            //&lt;debug error&gt;
            Ext.Logger.error(&quot;You must specify a valid side (left, right, top or botom) to dock the menu.&quot;);
            //&lt;/debug&gt;
            return;
        }

        var menus = me.getMenus();

        if (!menus) {
            menus = {};
        }

        // Add a listener to show this menu on swipe
        if (!me.addedSwipeListener) {
            me.addedSwipeListener = true;

            me.element.on({
                tap: me.onTap,
                swipestart: me.onSwipeStart,
                edgeswipestart: me.onEdgeSwipeStart,
                edgeswipe: me.onEdgeSwipe,
                edgeswipeend: me.onEdgeSwipeEnd,
                scope: me
            });

            // Add BB10 webworks API for swipe down.
            if (window.blackberry) {
                var toggleMenu = function() {
                    var menus = me.getMenus(),
                        menu = menus[&#39;top&#39;];

                    if (!menu) {
                        return;
                    }

                    if (menu.isHidden()) {
                        me.showMenu(&#39;top&#39;);
                    } else {
                        me.hideMenu(&#39;top&#39;);
                    }
                };

                if (blackberry.app &amp;&amp; blackberry.app.event &amp;&amp; blackberry.app.event.onSwipeDown) {
                    blackberry.app.event.onSwipeDown(toggleMenu); // PlayBook
                }
                else if (blackberry.event &amp;&amp; blackberry.event.addEventListener) {
                    blackberry.event.addEventListener(&quot;swipedown&quot;, toggleMenu); // BB10
                }
            }
        }

        menus[config.side] = menu;
        menu.$reveal = Boolean(config.reveal);
        menu.$cover = config.cover !== false &amp;&amp; !menu.$reveal;
        menu.$side = config.side;

        me.fixMenuSize(menu, config.side);

        if (config.side == &#39;left&#39;) {
            menu.setLeft(0);
            menu.setRight(null);
            menu.setTop(0);
            menu.setBottom(0);
        }
        else if (config.side == &#39;right&#39;) {
            menu.setLeft(null);
            menu.setRight(0);
            menu.setTop(0);
            menu.setBottom(0);
        }
        else if (config.side == &#39;top&#39;) {
            menu.setLeft(0);
            menu.setRight(0);
            menu.setTop(0);
            menu.setBottom(null);
        }
        else if (config.side == &#39;bottom&#39;) {
            menu.setLeft(0);
            menu.setRight(0);
            menu.setTop(null);
            menu.setBottom(0);
        }

        me.setMenus(menus);
    },

<span id='Ext-viewport-Default-method-removeMenu'>    /**
</span>     * Removes a menu from a specified side.
     * @param {String} side The side to remove the menu from
     */
    removeMenu: function(side) {
        var menus = this.getMenus() || {},
            menu = menus[side];

        if(menu) this.hideMenu(side);
        delete menus[side];
        this.setMenus(menus);
    },

<span id='Ext-viewport-Default-method-fixMenuSize'>    /**
</span>     * @private
     * Changes the sizing of the specified menu so that it displays correctly when shown.
     */
    fixMenuSize: function(menu, side) {
        if (side == &#39;top&#39; || side == &#39;bottom&#39;) {
            menu.setWidth(&#39;100%&#39;);
        }
        else if (side == &#39;left&#39; || side == &#39;right&#39;) {
            menu.setHeight(&#39;100%&#39;);
        }
    },

<span id='Ext-viewport-Default-method-showMenu'>    /**
</span>     * Shows a menu specified by the menu&#39;s side.
     * @param {String} side The side which the menu is placed.
     */
    showMenu: function(side) {
        var menus = this.getMenus(),
            menu = menus[side],
            before, after,
            viewportBefore, viewportAfter;

        if (!menu || menu.isAnimating) {
            return;
        }

        this.hideOtherMenus(side);

        before = {
            translateX: 0,
            translateY: 0
        };

        after = {
            translateX: 0,
            translateY: 0
        };

        viewportBefore = {
            translateX: 0,
            translateY: 0
        };

        viewportAfter = {
            translateX: 0,
            translateY: 0
        };

        if (menu.$reveal) {
            Ext.getBody().insertFirst(menu.element);
        }
        else {
            Ext.Viewport.add(menu);
        }

        menu.show();
        menu.addCls(&#39;x-&#39; + side);

        var size = (side == &#39;left&#39; || side == &#39;right&#39;) ? menu.element.getWidth() : menu.element.getHeight();

        if (side == &#39;left&#39;) {
            before.translateX = -size;
            viewportAfter.translateX = size;
        }
        else if (side == &#39;right&#39;) {
            before.translateX = size;
            viewportAfter.translateX = -size;
        }
        else if (side == &#39;top&#39;) {
            before.translateY = -size;
            viewportAfter.translateY = size;
        }
        else if (side == &#39;bottom&#39;) {
            before.translateY = size;
            viewportAfter.translateY = -size;
        }

        if (menu.$reveal) {
            if (Ext.browser.getPreferredTranslationMethod() != &#39;scrollposition&#39;) {
                menu.translate(0, 0);
            }
        }
        else {
            menu.translate(before.translateX, before.translateY);
        }

        if (menu.$cover) {
            menu.getTranslatable().on(&#39;animationend&#39;, function() {
                menu.isAnimating = false;
            }, this, {
                single: true
            });

            menu.translate(after.translateX, after.translateY, {
                preserveEndState: true,
                duration: 200
            });

        }
        else {
            this.translate(viewportBefore.translateX, viewportBefore.translateY);


            this.getTranslatable().on(&#39;animationend&#39;, function() {
                menu.isAnimating = false;
            }, this, {
                single: true
            });

            this.translate(viewportAfter.translateX, viewportAfter.translateY, {
                preserveEndState: true,
                duration: 200
            });
        }

        // Make the menu as animating
        menu.isAnimating = true;
    },

<span id='Ext-viewport-Default-method-hideMenu'>    /**
</span>     * Hides a menu specified by the menu&#39;s side.
     * @param {String} side The side which the menu is placed.
     */
    hideMenu: function(side, animate) {
        var menus = this.getMenus(),
            menu = menus[side],
            after, viewportAfter,
            size;

        animate = (animate === false) ? false : true;

        if (!menu || (menu.isHidden() || menu.isAnimating)) {
            return;
        }

        after = {
            translateX: 0,
            translateY: 0
        };

        viewportAfter = {
            translateX: 0,
            translateY: 0
        };

        size = (side == &#39;left&#39; || side == &#39;right&#39;) ? menu.element.getWidth() : menu.element.getHeight();

        if (side == &#39;left&#39;) {
            after.translateX = -size;
        }
        else if (side == &#39;right&#39;) {
            after.translateX = size;
        }
        else if (side == &#39;top&#39;) {
            after.translateY = -size;
        }
        else if (side == &#39;bottom&#39;) {
            after.translateY = size;
        }

        if (menu.$cover) {
            if (animate) {
                menu.getTranslatable().on(&#39;animationend&#39;, function() {
                    menu.isAnimating = false;
                    menu.hide();
                }, this, {
                    single: true
                });

                menu.translate(after.translateX, after.translateY, {
                    preserveEndState: true,
                    duration: 200
                });
            }
            else {
                menu.translate(after.translateX, after.translateY);
                menu.hide()
            }
        }
        else {
            if (animate) {
                this.getTranslatable().on(&#39;animationend&#39;, function() {
                    menu.isAnimating = false;
                    menu.hide();
                }, this, {
                    single: true
                });

                this.translate(viewportAfter.translateX, viewportAfter.translateY, {
                    preserveEndState: true,
                    duration: 200
                });
            }
            else {
                this.translate(viewportAfter.translateX, viewportAfter.translateY);
                menu.hide();
            }
        }
    },

<span id='Ext-viewport-Default-method-hideAllMenus'>    /**
</span>     * Hides all visible menus.
     */
    hideAllMenus: function(animation) {
        var menus = this.getMenus();

        for (var side in menus) {
            this.hideMenu(side, animation);
        }
    },

<span id='Ext-viewport-Default-method-hideOtherMenus'>    /**
</span>     * Hides all menus except for the side specified
     * @param {String} side         Side(s) not to hide
     * @param {String} animation    Animation to hide with
     */
    hideOtherMenus: function(side, animation){
        var menus = this.getMenus();

        for (var menu in menus) {
            if (side != menu) {
                this.hideMenu(menu, animation);
            }
        }
    },

<span id='Ext-viewport-Default-method-toggleMenu'>    /**
</span>     * Toggles the menu specified by side
     * @param {String} side The side which the menu is placed.
     */
    toggleMenu: function(side) {
        var menus = this.getMenus(), menu;
        if (menus[side]) {
            menu = menus[side];
            if (menu.isHidden()) {
                this.showMenu(side);
            } else {
                this.hideMenu(side);
            }
        }
    },

<span id='Ext-viewport-Default-method-sideForDirection'>    /**
</span>     * @private
     */
    sideForDirection: function(direction) {
        if (direction == &#39;left&#39;) {
            return &#39;right&#39;;
        }
        else if (direction == &#39;right&#39;) {
            return &#39;left&#39;;
        }
        else if (direction == &#39;up&#39;) {
            return &#39;bottom&#39;;
        }
        else if (direction == &#39;down&#39;) {
            return &#39;top&#39;;
        }
    },

<span id='Ext-viewport-Default-method-sideForSwipeDirection'>    /**
</span>     * @private
     */
    sideForSwipeDirection: function(direction) {
        if (direction == &quot;up&quot;) {
            return  &quot;top&quot;;
        }
        else if (direction == &quot;down&quot;) {
            return &quot;bottom&quot;;
        }
        return direction;
    },

<span id='Ext-viewport-Default-method-onTap'>    /**
</span>     * @private
     */
    onTap: function(e) {
        // this.hideAllMenus();
    },

<span id='Ext-viewport-Default-method-onSwipeStart'>    /**
</span>     * @private
     */
    onSwipeStart: function(e) {
        var side = this.sideForSwipeDirection(e.direction);
        this.hideMenu(side);
    },

<span id='Ext-viewport-Default-method-onEdgeSwipeStart'>    /**
</span>     * @private
     */
    onEdgeSwipeStart: function(e) {
        var side = this.sideForDirection(e.direction),
            menus = this.getMenus(),
            menu = menus[side],
            menuSide, checkMenu;

        if (!menu || !menu.isHidden()) {
            return;
        }

        for (menuSide in menus) {
            checkMenu = menus[menuSide];
            if (checkMenu.isHidden() !== false) {
                return;
            }
        }

        this.$swiping = true;

        this.hideAllMenus(false);

        // show the menu first so we can calculate the size
        if (menu.$reveal) {
            Ext.getBody().insertFirst(menu.element);
        }
        else {
            Ext.Viewport.add(menu);
        }
        menu.show();

        var size = (side == &#39;left&#39; || side == &#39;right&#39;) ? menu.element.getWidth() : menu.element.getHeight(),
            after, viewportAfter;

        after = {
            translateX: 0,
            translateY: 0
        };

        viewportAfter = {
            translateX: 0,
            translateY: 0
        };

        if (side == &#39;left&#39;) {
            after.translateX = -size;
        }
        else if (side == &#39;right&#39;) {
            after.translateX = size;
        }
        else if (side == &#39;top&#39;) {
            after.translateY = -size;
        }
        else if (side == &#39;bottom&#39;) {
            after.translateY = size;
        }

        var transformStyleName = &#39;webkitTransform&#39; in document.createElement(&#39;div&#39;).style ? &#39;webkitTransform&#39; : &#39;transform&#39;,
            setTransform = menu.element.dom.style[transformStyleName];

        if (setTransform) {
            menu.element.dom.style[transformStyleName] = &#39;&#39;;
        }

        if (menu.$reveal) {
            if (Ext.browser.getPreferredTranslationMethod() != &#39;scrollposition&#39;) {
                menu.translate(0, 0);
            }
        }
        else {
            menu.translate(after.translateX, after.translateY);
        }

        if (!menu.$cover) {
            if (setTransform) {
                this.innerElement.dom.style[transformStyleName] = &#39;&#39;;
            }

            this.translate(viewportAfter.translateX, viewportAfter.translateY);
        }
    },

<span id='Ext-viewport-Default-method-onEdgeSwipe'>    /**
</span>     * @private
     */
    onEdgeSwipe: function(e) {
        var side = this.sideForDirection(e.direction),
            menu = this.getMenus()[side];

        if (!menu || !this.$swiping) {
            return;
        }

        var size = (side == &#39;left&#39; || side == &#39;right&#39;) ? menu.element.getWidth() : menu.element.getHeight(),
            after, viewportAfter,
            movement = Math.min(e.distance - size, 0),
            viewportMovement = Math.min(e.distance, size);

        after = {
            translateX: 0,
            translateY: 0
        };

        viewportAfter = {
            translateX: 0,
            translateY: 0
        };

        if (side == &#39;left&#39;) {
            after.translateX = movement;
            viewportAfter.translateX = viewportMovement;
        }
        else if (side == &#39;right&#39;) {
            after.translateX = -movement;
            viewportAfter.translateX = -viewportMovement;
        }
        else if (side == &#39;top&#39;) {
            after.translateY = movement;
            viewportAfter.translateY = viewportMovement;
        }
        else if (side == &#39;bottom&#39;) {
            after.translateY = -movement;
            viewportAfter.translateY = -viewportMovement;
        }

        if (menu.$cover) {
            menu.translate(after.translateX, after.translateY);
        }
        else {
            this.translate(viewportAfter.translateX, viewportAfter.translateY);
        }
    },

<span id='Ext-viewport-Default-method-onEdgeSwipeEnd'>    /**
</span>     * @private
     */
    onEdgeSwipeEnd: function(e) {
        var side = this.sideForDirection(e.direction),
            menu = this.getMenus()[side],
            shouldRevert = false;

        if (!menu) {
            return;
        }

        var size = (side == &#39;left&#39; || side == &#39;right&#39;) ? menu.element.getWidth() : menu.element.getHeight(),
            velocity = (e.flick) ? e.flick.velocity : 0;

        // check if continuing in the right direction
        if (side == &#39;right&#39;) {
            if (velocity.x &gt; 0) {
                shouldRevert = true;
            }
        }
        else if (side == &#39;left&#39;) {
            if (velocity.x &lt; 0) {
                shouldRevert = true;
            }
        }
        else if (side == &#39;top&#39;) {
            if (velocity.y &lt; 0) {
                shouldRevert = true;
            }
        }
        else if (side == &#39;bottom&#39;) {
            if (velocity.y &gt; 0) {
                shouldRevert = true;
            }
        }

        var movement = (shouldRevert) ? size : 0,
            viewportMovement = (shouldRevert) ? 0 : -size,
            after, viewportAfter;

        after = {
            translateX: 0,
            translateY: 0
        };

        viewportAfter = {
            translateX: 0,
            translateY: 0
        };

        if (side == &#39;left&#39;) {
            after.translateX = -movement;
            viewportAfter.translateX = -viewportMovement;
        }
        else if (side == &#39;right&#39;) {
            after.translateX = movement;
            viewportAfter.translateX = viewportMovement;
        }
        else if (side == &#39;top&#39;) {
            after.translateY = -movement;
            viewportAfter.translateY = -viewportMovement;
        }
        else if (side == &#39;bottom&#39;) {
            after.translateY = movement;
            viewportAfter.translateY = viewportMovement;
        }

        // Move the viewport if cover is not enabled
        if (menu.$cover) {
            menu.getTranslatable().on(&#39;animationend&#39;, function() {
                if (shouldRevert) {
                    menu.hide();
                }
            }, this, {
                single: true
            });

            menu.translate(after.translateX, after.translateY, {
                preserveEndState: true,
                duration: 200
            });

        }
        else {
            this.getTranslatable().on(&#39;animationend&#39;, function() {
                if (shouldRevert) {
                    menu.hide();
                }
            }, this, {
                single: true
            });

            this.translate(viewportAfter.translateX, viewportAfter.translateY, {
                preserveEndState: true,
                duration: 200
            });
        }

        this.$swiping = false;
    }
});
</pre>
</body>
</html>
