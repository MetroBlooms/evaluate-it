<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-dataview-DataView'>/**
</span> * @aside guide dataview
 *
 * DataView makes it easy to create lots of components dynamically, usually based off a {@link Ext.data.Store Store}.
 * It&#39;s great for rendering lots of data from your server backend or any other data source and is what powers
 * components like {@link Ext.List}.
 *
 * Use DataView whenever you want to show sets of the same component many times, for examples in apps like these:
 *
 * - List of messages in an email app
 * - Showing latest news/tweets
 * - Tiled set of albums in an HTML5 music player
 *
 * # Creating a Simple DataView
 *
 * At its simplest, a DataView is just a Store full of data and a simple template that we use to render each item:
 *
 *     @example miniphone preview
 *     var touchTeam = Ext.create(&#39;Ext.DataView&#39;, {
 *         fullscreen: true,
 *         store: {
 *             fields: [&#39;name&#39;, &#39;age&#39;],
 *             data: [
 *                 {name: &#39;Jamie&#39;,  age: 100},
 *                 {name: &#39;Rob&#39;,   age: 21},
 *                 {name: &#39;Tommy&#39;, age: 24},
 *                 {name: &#39;Jacky&#39;, age: 24},
 *                 {name: &#39;Ed&#39;,   age: 26}
 *             ]
 *         },
 *
 *         itemTpl: &#39;&lt;div&gt;{name} is {age} years old&lt;/div&gt;&#39;
 *     });
 *
 * Here we just defined everything inline so it&#39;s all local with nothing being loaded from a server. For each of the 5
 * data items defined in our Store, DataView will render a {@link Ext.Component Component} and pass in the name and age
 * data. The component will use the tpl we provided above, rendering the data in the curly bracket placeholders we
 * provided.
 *
 * Because DataView is integrated with Store, any changes to the Store are immediately reflected on the screen. For
 * example, if we add a new record to the Store it will be rendered into our DataView:
 *
 *     touchTeam.getStore().add({
 *         name: &#39;Abe Elias&#39;,
 *         age: 33
 *     });
 *
 * We didn&#39;t have to manually update the DataView, it&#39;s just automatically updated. The same happens if we modify one
 * of the existing records in the Store:
 *
 *     touchTeam.getStore().getAt(0).set(&#39;age&#39;, 42);
 *
 * This will get the first record in the Store (Jamie), change the age to 42 and automatically update what&#39;s on the
 * screen.
 *
 *     @example miniphone
 *     var touchTeam = Ext.create(&#39;Ext.DataView&#39;, {
 *         fullscreen: true,
 *         store: {
 *             fields: [&#39;name&#39;, &#39;age&#39;],
 *             data: [
 *                 {name: &#39;Jamie&#39;,  age: 100},
 *                 {name: &#39;Rob&#39;,   age: 21},
 *                 {name: &#39;Tommy&#39;, age: 24},
 *                 {name: &#39;Jacky&#39;, age: 24},
 *                 {name: &#39;Ed&#39;,   age: 26}
 *             ]
 *         },
 *
 *         itemTpl: &#39;&lt;div&gt;{name} is {age} years old&lt;/div&gt;&#39;
 *     });
 *
 *     touchTeam.getStore().add({
 *         name: &#39;Abe Elias&#39;,
 *         age: 33
 *     });
 *
 *     touchTeam.getStore().getAt(0).set(&#39;age&#39;, 42);
 *
 * # Loading data from a server
 *
 * We often want to load data from our server or some other web service so that we don&#39;t have to hard code it all
 * locally. Let&#39;s say we want to load some horror movies from Rotten Tomatoes into a DataView, and for each one
 * render the cover image and title. To do this all we have to do is grab an api key from rotten tomatoes (http://developer.rottentomatoes.com/)
 * and modify the {@link #store} and {@link #itemTpl} a little:
 *
 *     @example portrait
 *     Ext.create(&#39;Ext.DataView&#39;, {
 *         fullscreen: true,
 *         store: {
 *             autoLoad: true,
 *             fields: [&#39;id&#39;, &#39;title&#39;,
 *              {
 *                  name:&#39;thumbnail_image&#39;,
 *                  convert: function(v, record) {return record.raw.posters.thumbnail; }
 *              }],
 *
 *             proxy: {
 *                 type: &#39;jsonp&#39;,
 *                 // Modify this line with your API key, pretty please...
 *                 url: &#39;http://api.rottentomatoes.com/api/public/v1.0/movies.json?apikey=hbjgfgryw8tygxztr5wtag3u&amp;q=Horror&#39;,
 *
 *                 reader: {
 *                     type: &#39;json&#39;,
 *                     rootProperty: &#39;results&#39;
 *                 }
 *             }
 *         },
 *
 *         itemTpl: &#39;&lt;img src=&quot;{thumbnail_image}&quot; /&gt;&lt;p&gt;{title}&lt;/p&gt;&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;&#39;
 *     });
 *
 * The Store no longer has hard coded data, instead we&#39;ve provided a {@link Ext.data.proxy.Proxy Proxy}, which fetches
 * the data for us. In this case we used a JSON-P proxy so that we can load from Twitter&#39;s JSON-P search API. We also
 * specified the fields present for each tweet, and used Store&#39;s {@link Ext.data.Store#autoLoad autoLoad} configuration
 * to load automatically. Finally, we configured a Reader to decode the response from Twitter, telling it to expect
 * JSON and that the tweets can be found in the &#39;results&#39; part of the JSON response.
 *
 * The last thing we did is update our template to render the image, Twitter username and message. All we need to do
 * now is add a little CSS to style the list the way we want it and we end up with a very basic Twitter viewer. Click
 * the preview button on the example above to see it in action.
 */
Ext.define(&#39;Ext.dataview.DataView&#39;, {
    extend: &#39;Ext.Container&#39;,

    alternateClassName: &#39;Ext.DataView&#39;,

    mixins: [&#39;Ext.mixin.Selectable&#39;],

    xtype: &#39;dataview&#39;,

    requires: [
        &#39;Ext.LoadMask&#39;,
        &#39;Ext.data.StoreManager&#39;,
        &#39;Ext.dataview.component.Container&#39;,
        &#39;Ext.dataview.element.Container&#39;
    ],

<span id='Ext-dataview-DataView-event-containertap'>    /**
</span>     * @event containertap
     * Fires when a tap occurs and it is not on a template node.
     * @removed 2.0.0
     */

<span id='Ext-dataview-DataView-event-itemtouchstart'>    /**
</span>     * @event itemtouchstart
     * Fires whenever an item is touched
     * @param {Ext.dataview.DataView} this
     * @param {Number} index The index of the item touched
     * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem touched
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Ext.EventObject} e The event object
     */

<span id='Ext-dataview-DataView-event-itemtouchmove'>    /**
</span>     * @event itemtouchmove
     * Fires whenever an item is moved
     * @param {Ext.dataview.DataView} this
     * @param {Number} index The index of the item moved
     * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem moved
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Ext.EventObject} e The event object
     */

<span id='Ext-dataview-DataView-event-itemtouchend'>    /**
</span>     * @event itemtouchend
     * Fires whenever an item is touched
     * @param {Ext.dataview.DataView} this
     * @param {Number} index The index of the item touched
     * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem touched
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Ext.EventObject} e The event object
     */

<span id='Ext-dataview-DataView-event-itemtap'>    /**
</span>     * @event itemtap
     * Fires whenever an item is tapped
     * @param {Ext.dataview.DataView} this
     * @param {Number} index The index of the item tapped
     * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem tapped
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Ext.EventObject} e The event object
     */

<span id='Ext-dataview-DataView-event-itemtaphold'>    /**
</span>     * @event itemtaphold
     * Fires whenever an item&#39;s taphold event fires
     * @param {Ext.dataview.DataView} this
     * @param {Number} index The index of the item touched
     * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem touched
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Ext.EventObject} e The event object
     */

<span id='Ext-dataview-DataView-event-itemsingletap'>    /**
</span>     * @event itemsingletap
     * Fires whenever an item is singletapped
     * @param {Ext.dataview.DataView} this
     * @param {Number} index The index of the item singletapped
     * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem singletapped
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Ext.EventObject} e The event object
     */

<span id='Ext-dataview-DataView-event-itemdoubletap'>    /**
</span>     * @event itemdoubletap
     * Fires whenever an item is doubletapped
     * @param {Ext.dataview.DataView} this
     * @param {Number} index The index of the item doubletapped
     * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem doubletapped
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Ext.EventObject} e The event object
     */

<span id='Ext-dataview-DataView-event-itemswipe'>    /**
</span>     * @event itemswipe
     * Fires whenever an item is swiped
     * @param {Ext.dataview.DataView} this
     * @param {Number} index The index of the item swiped
     * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem swiped
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Ext.EventObject} e The event object
     */

<span id='Ext-dataview-DataView-event-select'>    /**
</span>     * @event select
     * @preventable doItemSelect
     * Fires whenever an item is selected
     * @param {Ext.dataview.DataView} this
     * @param {Ext.data.Model} record The record associated to the item
     */

<span id='Ext-dataview-DataView-event-deselect'>    /**
</span>     * @event deselect
     * @preventable doItemDeselect
     * Fires whenever an item is deselected
     * @param {Ext.dataview.DataView} this
     * @param {Ext.data.Model} record The record associated to the item
     * @param {Boolean} supressed Flag to suppress the event
     */

<span id='Ext-dataview-DataView-event-refresh'>    /**
</span>     * @event refresh
     * @preventable doRefresh
     * Fires whenever the DataView is refreshed
     * @param {Ext.dataview.DataView} this
     */

<span id='Ext-dataview-DataView-event-add'>    /**
</span>     * @hide
     * @event add
     */

<span id='Ext-dataview-DataView-event-remove'>    /**
</span>     * @hide
     * @event remove
     */

<span id='Ext-dataview-DataView-event-move'>    /**
</span>     * @hide
     * @event move
     */

    config: {
<span id='Ext-dataview-DataView-cfg-layout'>        /**
</span>         * @cfg layout
         * Hide layout config in DataView. It only causes confusion.
         * @accessor
         * @private
         */

<span id='Ext-dataview-DataView-cfg-store'>        /**
</span>         * @cfg {Ext.data.Store/Object} store
         * Can be either a Store instance or a configuration object that will be turned into a Store. The Store is used
         * to populate the set of items that will be rendered in the DataView. See the DataView intro documentation for
         * more information about the relationship between Store and DataView.
         * @accessor
         */
        store: null,

<span id='Ext-dataview-DataView-cfg-data'>        /**
</span>         * @cfg {Object[]} data
         * @inheritdoc
         */
        data: null,

<span id='Ext-dataview-DataView-cfg-baseCls'>        /**
</span>         * @cfg baseCls
         * @inheritdoc
         */
        baseCls: Ext.baseCSSPrefix + &#39;dataview&#39;,

<span id='Ext-dataview-DataView-cfg-emptyText'>        /**
</span>         * @cfg {String} emptyText
         * The text to display in the view when there is no data to display
         */
        emptyText: null,

<span id='Ext-dataview-DataView-cfg-deferEmptyText'>        /**
</span>         * @cfg {Boolean} deferEmptyText `true` to defer `emptyText` being applied until the store&#39;s first load.
         */
        deferEmptyText: true,

<span id='Ext-dataview-DataView-cfg-itemTpl'>        /**
</span>         * @cfg {String/String[]/Ext.XTemplate} itemTpl
         * The `tpl` to use for each of the items displayed in this DataView.
         */
        itemTpl: &#39;&lt;div&gt;{text}&lt;/div&gt;&#39;,

<span id='Ext-dataview-DataView-cfg-pressedCls'>        /**
</span>         * @cfg {String} pressedCls
         * The CSS class to apply to an item on the view while it is being pressed.
         * @accessor
         */
        pressedCls: &#39;x-item-pressed&#39;,

<span id='Ext-dataview-DataView-cfg-itemCls'>        /**
</span>         * @cfg {String} itemCls
         * An additional CSS class to apply to items within the DataView.
         * @accessor
         */
        itemCls: null,

<span id='Ext-dataview-DataView-cfg-selectedCls'>        /**
</span>         * @cfg {String} selectedCls
         * The CSS class to apply to an item on the view while it is selected.
         * @accessor
         */
        selectedCls: &#39;x-item-selected&#39;,

<span id='Ext-dataview-DataView-cfg-triggerEvent'>        /**
</span>         * @cfg {String} triggerEvent
         * Determines what type of touch event causes an item to be selected.
         * Valid options are: &#39;itemtap&#39;, &#39;itemsingletap&#39;, &#39;itemdoubletap&#39;, &#39;itemswipe&#39;, &#39;itemtaphold&#39;.
         * @accessor
         */
        triggerEvent: &#39;itemtap&#39;,

<span id='Ext-dataview-DataView-cfg-triggerCtEvent'>        /**
</span>         * @cfg {String} triggerCtEvent
         * Determines what type of touch event is recognized as a touch on the container.
         * Valid options are &#39;tap&#39; and &#39;singletap&#39;.
         * @accessor
         */
        triggerCtEvent: &#39;tap&#39;,

<span id='Ext-dataview-DataView-cfg-deselectOnContainerClick'>        /**
</span>         * @cfg {Boolean} deselectOnContainerClick
         * When set to true, tapping on the DataView&#39;s background (i.e. not on
         * an item in the DataView) will deselect any currently selected items.
         * @accessor
         */
        deselectOnContainerClick: true,

<span id='Ext-dataview-DataView-cfg-scrollable'>        /**
</span>         * @cfg scrollable
         * @inheritdoc
         */
        scrollable: true,

<span id='Ext-dataview-DataView-cfg-inline'>        /**
</span>         * @cfg {Boolean/Object} inline
         * When set to `true` the items within the DataView will have their display set to inline-block
         * and be arranged horizontally. By default the items will wrap to the width of the DataView.
         * Passing an object with `{ wrap: false }` will turn off this wrapping behavior and overflowed
         * items will need to be scrolled to horizontally.
         * @accessor
         */
        inline: null,

<span id='Ext-dataview-DataView-cfg-pressedDelay'>        /**
</span>         * @cfg {Number} pressedDelay
         * The amount of delay between the `tapstart` and the moment we add the `pressedCls`.
         *
         * Settings this to `true` defaults to 100ms.
         * @accessor
         */
        pressedDelay: 100,

<span id='Ext-dataview-DataView-cfg-loadingText'>        /**
</span>         * @cfg {String/Boolean} loadingText
         * A string to display during data load operations.  If specified, this text will be
         * displayed in a loading div and the view&#39;s contents will be cleared while loading, otherwise the view&#39;s
         * contents will continue to display normally until the new data is loaded and the contents are replaced.
         */
        loadingText: &#39;Loading...&#39;,

<span id='Ext-dataview-DataView-cfg-useComponents'>        /**
</span>         * @cfg {Boolean} useComponents
         * Flag the use a component based DataView implementation.  This allows the full use of components in the
         * DataView at the cost of some performance.
         *
         * Checkout the [DataView Guide](#!/guide/dataview) for more information on using this configuration.
         * @accessor
         */
        useComponents: null,

<span id='Ext-dataview-DataView-cfg-itemConfig'>        /**
</span>         * @cfg {Object} itemConfig
         * A configuration object that is passed to every item created by a component based DataView. Because each
         * item that a DataView renders is a Component, we can pass configuration options to each component to
         * easily customize how each child component behaves.
         *
         * __Note:__ this is only used when `{@link #useComponents}` is `true`.
         * @accessor
         */
        itemConfig: {},

<span id='Ext-dataview-DataView-cfg-maxItemCache'>        /**
</span>         * @cfg {Number} maxItemCache
         * Maintains a cache of reusable components when using a component based DataView.  Improving performance at
         * the cost of memory.
         *
         * __Note:__ this is currently only used when `{@link #useComponents}` is `true`.
         * @accessor
         */
        maxItemCache: 20,

<span id='Ext-dataview-DataView-cfg-defaultType'>        /**
</span>         * @cfg {String} defaultType
         * The xtype used for the component based DataView.
         *
         * __Note:__ this is only used when `{@link #useComponents}` is `true`.
         * @accessor
         */
        defaultType: &#39;dataitem&#39;,

<span id='Ext-dataview-DataView-cfg-scrollToTopOnRefresh'>        /**
</span>         * @cfg {Boolean} scrollToTopOnRefresh
         * Scroll the DataView to the top when the DataView is refreshed.
         * @accessor
         */
        scrollToTopOnRefresh: true
    },

<span id='Ext-dataview-DataView-method-constructor'>    constructor: function(config) {
</span>        var me = this,
            layout;

        me.hasLoadedStore = false;

        me.mixins.selectable.constructor.apply(me, arguments);

        me.indexOffset = 0;

        me.callParent(arguments);

        //&lt;debug&gt;
        layout = this.getLayout();
        if (layout &amp;&amp; !layout.isAuto) {
            Ext.Logger.error(&#39;The base layout for a DataView must always be an Auto Layout&#39;);
        }
        //&lt;/debug&gt;
    },

<span id='Ext-dataview-DataView-method-updateItemCls'>    updateItemCls: function(newCls, oldCls) {
</span>        var container = this.container;
        if (container) {
            if (oldCls) {
                container.doRemoveItemCls(oldCls);
            }
            if (newCls) {
                container.doAddItemCls(newCls);
            }
        }
    },

<span id='Ext-dataview-DataView-property-storeEventHooks'>    storeEventHooks: {
</span>        beforeload: &#39;onBeforeLoad&#39;,
        load: &#39;onLoad&#39;,
        refresh: &#39;refresh&#39;,
        addrecords: &#39;onStoreAdd&#39;,
        removerecords: &#39;onStoreRemove&#39;,
        updaterecord: &#39;onStoreUpdate&#39;
    },

<span id='Ext-dataview-DataView-method-initialize'>    initialize: function() {
</span>        this.callParent();
        var me = this,
            container,
            triggerEvent = me.getTriggerEvent();

        me.on(me.getTriggerCtEvent(), me.onContainerTrigger, me);

        container = me.container = this.add(new Ext.dataview[me.getUseComponents() ? &#39;component&#39; : &#39;element&#39;].Container({
            baseCls: this.getBaseCls()
        }));
        container.dataview = me;

        if (triggerEvent) {
            me.on(triggerEvent, me.onItemTrigger, me);
        }

        container.on({
            itemtouchstart: &#39;onItemTouchStart&#39;,
            itemtouchend: &#39;onItemTouchEnd&#39;,
            itemtap: &#39;onItemTap&#39;,
            itemtaphold: &#39;onItemTapHold&#39;,
            itemtouchmove: &#39;onItemTouchMove&#39;,
            itemsingletap: &#39;onItemSingleTap&#39;,
            itemdoubletap: &#39;onItemDoubleTap&#39;,
            itemswipe: &#39;onItemSwipe&#39;,
            scope: me
        });

        if (me.getStore()) {
            if (me.isPainted()) {
                me.refresh();
            }
            else {
                me.on({
                    painted: &#39;refresh&#39;,
                    single: true
                });
            }
        }
    },

<span id='Ext-dataview-DataView-method-applyInline'>    applyInline: function(config) {
</span>        if (Ext.isObject(config)) {
            config = Ext.apply({}, config);
        }
        return config;
    },

<span id='Ext-dataview-DataView-method-updateInline'>    updateInline: function(newInline, oldInline) {
</span>        var baseCls = this.getBaseCls();
        if (oldInline) {
            this.removeCls([baseCls + &#39;-inlineblock&#39;, baseCls + &#39;-nowrap&#39;]);
        }
        if (newInline) {
            this.addCls(baseCls + &#39;-inlineblock&#39;);
            if (Ext.isObject(newInline) &amp;&amp; newInline.wrap === false) {
                this.addCls(baseCls + &#39;-nowrap&#39;);
            }
            else {
                this.removeCls(baseCls + &#39;-nowrap&#39;);
            }
        }
    },

<span id='Ext-dataview-DataView-method-prepareData'>    /**
</span>     * Function which can be overridden to provide custom formatting for each Record that is used by this
     * DataView&#39;s {@link #tpl template} to render each node.
     * @param {Object/Object[]} data The raw data object that was used to create the Record.
     * @param {Number} index the index number of the Record being prepared for rendering.
     * @param {Ext.data.Model} record The Record being prepared for rendering.
     * @return {Array/Object} The formatted data in a format expected by the internal {@link #tpl template}&#39;s `overwrite()` method.
     * (either an array if your params are numeric (i.e. `{0}`) or an object (i.e. `{foo: &#39;bar&#39;}`))
     */
    prepareData: function(data, index, record) {
        return data;
    },

<span id='Ext-dataview-DataView-method-onContainerTrigger'>    // apply to the selection model to maintain visual UI cues
</span>    onContainerTrigger: function(e) {
        var me = this;
        if (e.target != me.element.dom) {
            return;
        }
        if (me.getDeselectOnContainerClick() &amp;&amp; me.getStore()) {
            me.deselectAll();
        }
    },

<span id='Ext-dataview-DataView-method-onItemTrigger'>    // apply to the selection model to maintain visual UI cues
</span>    onItemTrigger: function(me, index) {
        if (!this.isDestroyed) {
            this.selectWithEvent(this.getStore().getAt(index));
        }
    },

<span id='Ext-dataview-DataView-method-doAddPressedCls'>    doAddPressedCls: function(record) {
</span>        var me = this,
            item = me.getItemAt(me.getStore().indexOf(record));
        if (Ext.isElement(item)) {
            item = Ext.get(item);
        }
        if (item) {
            if (item.isComponent) {
                item.renderElement.addCls(me.getPressedCls());
            } else {
                item.addCls(me.getPressedCls());
            }
        }
    },

<span id='Ext-dataview-DataView-method-onItemTouchStart'>    onItemTouchStart: function(container, target, index, e) {
</span>        var me = this,
            store = me.getStore(),
            record = store &amp;&amp; store.getAt(index);

        me.fireAction(&#39;itemtouchstart&#39;, [me, index, target, record, e], &#39;doItemTouchStart&#39;);
    },

<span id='Ext-dataview-DataView-method-doItemTouchStart'>    doItemTouchStart: function(me, index, target, record) {
</span>        var pressedDelay = me.getPressedDelay();

        if (record) {
            if (pressedDelay &gt; 0) {
                me.pressedTimeout = Ext.defer(me.doAddPressedCls, pressedDelay, me, [record]);
            }
            else {
                me.doAddPressedCls(record);
            }
        }
    },

<span id='Ext-dataview-DataView-method-onItemTouchEnd'>    onItemTouchEnd: function(container, target, index, e) {
</span>        var me = this,
            store = me.getStore(),
            record = store &amp;&amp; store.getAt(index);

        if (this.hasOwnProperty(&#39;pressedTimeout&#39;)) {
            clearTimeout(this.pressedTimeout);
            delete this.pressedTimeout;
        }

        if (record &amp;&amp; target) {
            if (target.isComponent) {
                target.renderElement.removeCls(me.getPressedCls());
            } else {
                target.removeCls(me.getPressedCls());
            }
        }

        me.fireEvent(&#39;itemtouchend&#39;, me, index, target, record, e);
    },

<span id='Ext-dataview-DataView-method-onItemTouchMove'>    onItemTouchMove: function(container, target, index, e) {
</span>        var me = this,
            store = me.getStore(),
            record = store &amp;&amp; store.getAt(index);

        if (me.hasOwnProperty(&#39;pressedTimeout&#39;)) {
            clearTimeout(me.pressedTimeout);
            delete me.pressedTimeout;
        }

        if (record &amp;&amp; target) {
            if (target.isComponent) {
                target.renderElement.removeCls(me.getPressedCls());
            } else {
                target.removeCls(me.getPressedCls());
            }
        }
        me.fireEvent(&#39;itemtouchmove&#39;, me, index, target, record, e);
    },

<span id='Ext-dataview-DataView-method-onItemTap'>    onItemTap: function(container, target, index, e) {
</span>        var me = this,
            store = me.getStore(),
            record = store &amp;&amp; store.getAt(index);

        me.fireEvent(&#39;itemtap&#39;, me, index, target, record, e);
    },

<span id='Ext-dataview-DataView-method-onItemTapHold'>    onItemTapHold: function(container, target, index, e) {
</span>        var me = this,
            store = me.getStore(),
            record = store &amp;&amp; store.getAt(index);

        me.fireEvent(&#39;itemtaphold&#39;, me, index, target, record, e);
    },

<span id='Ext-dataview-DataView-method-onItemSingleTap'>    onItemSingleTap: function(container, target, index, e) {
</span>        var me = this,
            store = me.getStore(),
            record = store &amp;&amp; store.getAt(index);

        me.fireEvent(&#39;itemsingletap&#39;, me, index, target, record, e);
    },

<span id='Ext-dataview-DataView-method-onItemDoubleTap'>    onItemDoubleTap: function(container, target, index, e) {
</span>        var me = this,
            store = me.getStore(),
            record = store &amp;&amp; store.getAt(index);

        me.fireEvent(&#39;itemdoubletap&#39;, me, index, target, record, e);
    },

<span id='Ext-dataview-DataView-method-onItemSwipe'>    onItemSwipe: function(container, target, index, e) {
</span>        var me = this,
            store = me.getStore(),
            record = store &amp;&amp; store.getAt(index);

        me.fireEvent(&#39;itemswipe&#39;, me, index, target, record, e);
    },

<span id='Ext-dataview-DataView-method-onItemSelect'>    // invoked by the selection model to maintain visual UI cues
</span>    onItemSelect: function(record, suppressEvent) {
        var me = this;
        if (suppressEvent) {
            me.doItemSelect(me, record);
        } else {
            me.fireAction(&#39;select&#39;, [me, record], &#39;doItemSelect&#39;);
        }
    },

<span id='Ext-dataview-DataView-method-doItemSelect'>    // invoked by the selection model to maintain visual UI cues
</span>    doItemSelect: function(me, record) {
        if (me.container &amp;&amp; !me.isDestroyed) {
            var item = me.getItemAt(me.getStore().indexOf(record));
            if (Ext.isElement(item)) {
                item = Ext.get(item);
            }
            if (item) {
                if (item.isComponent) {
                    item.renderElement.removeCls(me.getPressedCls());
                    item.renderElement.addCls(me.getSelectedCls());
                } else {
                    item.removeCls(me.getPressedCls());
                    item.addCls(me.getSelectedCls());
                }
            }
        }
    },

<span id='Ext-dataview-DataView-method-onItemDeselect'>    // invoked by the selection model to maintain visual UI cues
</span>    onItemDeselect: function(record, suppressEvent) {
        var me = this;
        if (me.container &amp;&amp; !me.isDestroyed) {
            if (suppressEvent) {
                me.doItemDeselect(me, record);
            }
            else {
                me.fireAction(&#39;deselect&#39;, [me, record, suppressEvent], &#39;doItemDeselect&#39;);
            }
        }
    },

<span id='Ext-dataview-DataView-method-doItemDeselect'>    doItemDeselect: function(me, record) {
</span>        var item = me.getItemAt(me.getStore().indexOf(record));

        if (Ext.isElement(item)) {
            item = Ext.get(item);
        }

        if (item) {
            if (item.isComponent) {
                item.renderElement.removeCls([me.getPressedCls(), me.getSelectedCls()]);
            } else {
                item.removeCls([me.getPressedCls(), me.getSelectedCls()]);
            }
        }
    },

<span id='Ext-dataview-DataView-method-updateData'>    updateData: function(data) {
</span>        var store = this.getStore();
        if (!store) {
            this.setStore(Ext.create(&#39;Ext.data.Store&#39;, {
                data: data,
                autoDestroy: true
            }));
        } else {
            store.add(data);
        }
    },

<span id='Ext-dataview-DataView-method-applyStore'>    applyStore: function(store) {
</span>        var me = this,
            bindEvents = Ext.apply({}, me.storeEventHooks, { scope: me }),
            proxy, reader;

        if (store) {
            store = Ext.data.StoreManager.lookup(store);
            if (store &amp;&amp; Ext.isObject(store) &amp;&amp; store.isStore) {
                store.on(bindEvents);
                proxy = store.getProxy();
                if (proxy) {
                    reader = proxy.getReader();
                    if (reader) {
                        reader.on(&#39;exception&#39;, &#39;handleException&#39;, this);
                    }
                }
            }
            //&lt;debug warn&gt;
            else {
                Ext.Logger.warn(&quot;The specified Store cannot be found&quot;, this);
            }
            //&lt;/debug&gt;
        }

        return store;
    },

<span id='Ext-dataview-DataView-method-handleException'>    /**
</span>     * Method called when the Store&#39;s Reader throws an exception
     * @method handleException
     */
    handleException: function() {
        this.setMasked(false);
    },

<span id='Ext-dataview-DataView-method-updateStore'>    updateStore: function(newStore, oldStore) {
</span>        var me = this,
            bindEvents = Ext.apply({}, me.storeEventHooks, { scope: me }),
            proxy, reader;

        if (oldStore &amp;&amp; Ext.isObject(oldStore) &amp;&amp; oldStore.isStore) {
            oldStore.un(bindEvents);

            if (!me.isDestroyed) {
                me.onStoreClear();
            }

            if (oldStore.getAutoDestroy()) {
                oldStore.destroy();
            }
            else {
                proxy = oldStore.getProxy();
                if (proxy) {
                    reader = proxy.getReader();
                    if (reader) {
                        reader.un(&#39;exception&#39;, &#39;handleException&#39;, this);
                    }
                }
            }
        }

        if (newStore) {
            if (newStore.isLoaded()) {
                this.hasLoadedStore = true;
            }

            if (newStore.isLoading()) {
                me.onBeforeLoad();
            }
            if (me.container) {
                me.refresh();
            }
        }
    },

<span id='Ext-dataview-DataView-method-onBeforeLoad'>    onBeforeLoad: function() {
</span>        var loadingText = this.getLoadingText();
        if (loadingText &amp;&amp; this.isPainted()) {
            this.setMasked({
                xtype: &#39;loadmask&#39;,
                message: loadingText
            });
        }

        this.hideEmptyText();
    },

<span id='Ext-dataview-DataView-method-updateEmptyText'>    updateEmptyText: function(newEmptyText, oldEmptyText) {
</span>        var me = this,
            store;

        if (oldEmptyText &amp;&amp; me.emptyTextCmp) {
            me.remove(me.emptyTextCmp, true);
            delete me.emptyTextCmp;
        }

        if (newEmptyText) {
            me.emptyTextCmp = me.add({
                xtype: &#39;component&#39;,
                cls: me.getBaseCls() + &#39;-emptytext&#39;,
                html: newEmptyText,
                hidden: true
            });
            store = me.getStore();
            if (store &amp;&amp; me.hasLoadedStore &amp;&amp; !store.getCount()) {
                this.showEmptyText();
            }
        }
    },

<span id='Ext-dataview-DataView-method-onLoad'>    onLoad: function(store) {
</span>        //remove any masks on the store
        this.hasLoadedStore = true;
        this.setMasked(false);

        if (!store.getCount()) {
            this.showEmptyText();
        }
    },

<span id='Ext-dataview-DataView-method-refresh'>    /**
</span>     * Refreshes the view by reloading the data from the store and re-rendering the template.
     */
    refresh: function() {
        var me = this,
            container = me.container;

        if (!me.getStore()) {
            if (!me.hasLoadedStore &amp;&amp; !me.getDeferEmptyText()) {
                me.showEmptyText();
            }
            return;
        }
        if (container) {
            me.fireAction(&#39;refresh&#39;, [me], &#39;doRefresh&#39;);
        }
    },

<span id='Ext-dataview-DataView-method-applyItemTpl'>    applyItemTpl: function(config) {
</span>        return (Ext.isObject(config) &amp;&amp; config.isTemplate) ? config : new Ext.XTemplate(config);
    },

<span id='Ext-dataview-DataView-method-onAfterRender'>    onAfterRender: function() {
</span>        var me = this;
        me.callParent(arguments);
        me.updateStore(me.getStore());
    },

<span id='Ext-dataview-DataView-method-getItemAt'>    /**
</span>     * Returns an item at the specified index.
     * @param {Number} index Index of the item.
     * @return {Ext.dom.Element/Ext.dataview.component.DataItem} item Item at the specified index.
     */
    getItemAt: function(index) {
        return this.getViewItems()[index - this.indexOffset];
    },

<span id='Ext-dataview-DataView-method-getItemIndex'>    /**
</span>     * Returns an index for the specified item.
     * @param {Number} item The item to locate.
     * @return {Number} Index for the specified item.
     */
    getItemIndex: function(item) {
        var index = this.getViewItems().indexOf(item);
        return (index === -1) ? index : this.indexOffset + index;
    },

<span id='Ext-dataview-DataView-method-getViewItems'>    /**
</span>     * Returns an array of the current items in the DataView.
     * @return {Ext.dom.Element[]/Ext.dataview.component.DataItem[]} Array of Items.
     */
    getViewItems: function() {
        return this.container.getViewItems();
    },

<span id='Ext-dataview-DataView-method-doRefresh'>    doRefresh: function(me) {
</span>        var container = me.container,
            store = me.getStore(),
            records = store.getRange(),
            items = me.getViewItems(),
            recordsLn = records.length,
            itemsLn = items.length,
            deltaLn = recordsLn - itemsLn,
            scrollable = me.getScrollable(),
            i, item;

        if (this.getScrollToTopOnRefresh() &amp;&amp; scrollable) {
            scrollable.getScroller().scrollToTop();
        }

        // No items, hide all the items from the collection.
        if (recordsLn &lt; 1) {
            me.onStoreClear();
            return;
        } else {
            me.hideEmptyText();
        }

        // Too many items, hide the unused ones
        if (deltaLn &lt; 0) {
            container.moveItemsToCache(itemsLn + deltaLn, itemsLn - 1);
            // Items can changed, we need to refresh our references
            items = me.getViewItems();
            itemsLn = items.length;
        }
        // Not enough items, create new ones
        else if (deltaLn &gt; 0) {
            container.moveItemsFromCache(store.getRange(itemsLn));
        }

        // Update Data and insert the new html for existing items
        for (i = 0; i &lt; itemsLn; i++) {
            item = items[i];
            container.updateListItem(records[i], item);
        }

        if (this.hasSelection()) {
            var selection = this.getSelection(),
                selectionLn = this.getSelectionCount(),
                record;
            for (i = 0; i &lt; selectionLn; i++) {
                record = selection[i];
                this.doItemSelect(this, record);
            }
        }
    },

<span id='Ext-dataview-DataView-method-showEmptyText'>    showEmptyText: function() {
</span>        if (this.getEmptyText() &amp;&amp; (this.hasLoadedStore || !this.getDeferEmptyText())) {
            this.emptyTextCmp.show();
        }
    },

<span id='Ext-dataview-DataView-method-hideEmptyText'>    hideEmptyText: function() {
</span>        if (this.getEmptyText()) {
            this.emptyTextCmp.hide();
        }
    },

<span id='Ext-dataview-DataView-method-destroy'>    destroy: function() {
</span>        var store = this.getStore(),
            proxy = (store &amp;&amp; store.getProxy()),
            reader = (proxy &amp;&amp; proxy.getReader());

        if (reader) {
            // TODO: Use un() instead of clearListeners() when TOUCH-2723 is fixed.
//          reader.un(&#39;exception&#39;, &#39;handleException&#39;, this);
            reader.clearListeners();
        }

        this.callParent(arguments);

        this.setStore(null);
    },

<span id='Ext-dataview-DataView-method-onStoreClear'>    onStoreClear: function() {
</span>        var me = this,
            container = me.container,
            items = me.getViewItems();

        container.moveItemsToCache(0, items.length - 1);
        this.showEmptyText();
    },

<span id='Ext-dataview-DataView-method-onStoreAdd'>    /**
</span>     * @private
     * @param {Ext.data.Store} store
     * @param {Array} records
     */
    onStoreAdd: function(store, records) {
        if (records) {
            this.hideEmptyText();
            this.container.moveItemsFromCache(records);
        }
    },

<span id='Ext-dataview-DataView-method-onStoreRemove'>    /**
</span>     * @private
     * @param {Ext.data.Store} store
     * @param {Array} records
     * @param {Array} indices
     */
    onStoreRemove: function(store, records, indices) {
        var container = this.container,
            ln = records.length,
            i;
        for (i = 0; i &lt; ln; i++) {
            container.moveItemsToCache(indices[i], indices[i]);
        }
    },

<span id='Ext-dataview-DataView-method-onStoreUpdate'>    /**
</span>     * @private
     * @param {Ext.data.Store} store
     * @param {Ext.data.Model} record
     * @param {Number} newIndex
     * @param {Number} oldIndex
     */
    onStoreUpdate: function(store, record, newIndex, oldIndex) {
        var me = this,
            container = me.container,
            item;

        oldIndex = (typeof oldIndex === &#39;undefined&#39;) ? newIndex : oldIndex;

        if (oldIndex !== newIndex) {
            container.updateAtNewIndex(oldIndex, newIndex, record);
            if (me.isSelected(record)) {
                me.doItemSelect(me, record);
            }
        }
        else {
            item = me.getViewItems()[newIndex];
            if (item) {
                // Bypassing setter because sometimes we pass the same record (different data)
                container.updateListItem(record, item);
            }
        }
    }
    //&lt;deprecated product=touch since=2.0&gt;
}, function() {

<span id='Ext-dataview-DataView-method-collectData'>    /**
</span>     * @member Ext.dataview.DataView
     * @method collectData
     * Function which can be overridden which returns the data object passed to
     * this DataView&#39;s template to render the whole DataView.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;collectData&#39;, null, &quot;Ext.dataview.DataView.collectData() has been removed&quot;);

<span id='Ext-dataview-DataView-method-findItemByChild'>    /**
</span>     * @member Ext.dataview.DataView
     * @method findItemByChild
     * Returns the template node the passed child belongs to, or `null` if it doesn&#39;t belong to one.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;findItemByChild&#39;, null, &quot;Ext.dataview.DataView.findItemByChild() has been removed&quot;);

<span id='Ext-dataview-DataView-method-findTargetByEvent'>    /**
</span>     * @member Ext.dataview.DataView
     * @method findTargetByEvent
     * Returns the template node by the Ext.EventObject or `null` if it is not found.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;findTargetByEvent&#39;, null, &quot;Ext.dataview.DataView.findTargetByEvent() has been removed&quot;);

<span id='Ext-dataview-DataView-method-getNode'>    /**
</span>     * @member Ext.dataview.DataView
     * @method getNode
     * Gets a template node.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;getNode&#39;, null, &quot;Ext.dataview.DataView.getNode() has been removed&quot;);

<span id='Ext-dataview-DataView-method-getNodes'>    /**
</span>     * @member Ext.dataview.DataView
     * @method getNodes
     * Gets a range nodes.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;getNodes&#39;, null, &quot;Ext.dataview.DataView.getNodes() has been removed&quot;);

<span id='Ext-dataview-DataView-method-getRecords'>    /**
</span>     * @member Ext.dataview.DataView
     * @method getRecords
     * Gets an array of the records from an array of nodes.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;getRecords&#39;, null, &quot;Ext.dataview.DataView.getRecords() has been removed&quot;);

<span id='Ext-dataview-DataView-method-getSelectedNodes'>    /**
</span>     * @member Ext.dataview.DataView
     * @method getSelectedNodes
     * Gets the currently selected nodes.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;getSelectedNodes&#39;, null, &quot;Ext.dataview.DataView.getSelectedNodes() has been removed&quot;);

<span id='Ext-dataview-DataView-method-getSelectedRecords'>    /**
</span>     * @member Ext.dataview.DataView
     * @method getSelectedRecords
     * Gets an array of the selected records.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;getSelectedRecords&#39;, null, &quot;Ext.dataview.DataView.getSelectedRecords() has been removed&quot;);

<span id='Ext-dataview-DataView-method-indexOf'>    /**
</span>     * @member Ext.dataview.DataView
     * @method indexOf
     * Finds the index of the passed node.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;indexOf&#39;, null, &quot;Ext.dataview.DataView.indexOf() has been removed&quot;);

<span id='Ext-dataview-DataView-method-refreshNode'>    /**
</span>     * @member Ext.dataview.DataView
     * @method refreshNode
     * Refreshes an individual node&#39;s data from the store.
     * @removed 2.0.0
     */
    Ext.deprecateMethod(this, &#39;refreshNode&#39;, null, &quot;Ext.dataview.DataView.refreshNode() has been removed&quot;);

<span id='Ext-dataview-DataView-method-bindStore'>    /**
</span>     * Binds a new {@link Ext.data.Store Store} to this DataView.
     * @deprecated 2.0 please use {@link #setStore} instead
     * @method bindStore
     */
    Ext.deprecateClassMethod(this, &#39;bindStore&#39;, &#39;setStore&#39;);

<span id='Ext-dataview-DataView-cfg-blockRefresh'>    /**
</span>     * @member Ext.dataview.DataView
     * @cfg {Boolean} blockRefresh
     * Set this to `true` to ignore `datachanged` events on the bound store.
     * @removed 2.0.0
     */
    Ext.deprecateProperty(this, &#39;blockRefresh&#39;, null, &quot;Ext.dataview.DataView.blockRefresh has been removed&quot;);

<span id='Ext-dataview-DataView-cfg-itemSelector'>    /**
</span>     * @member Ext.dataview.DataView
     * @cfg {Boolean} itemSelector
     * A simple CSS selector that will be used to determine what nodes this DataView will be working with.
     * @removed 2.0.0
     */
    Ext.deprecateProperty(this, &#39;itemSelector&#39;, null, &quot;Ext.dataview.DataView.itemSelector has been removed&quot;);

<span id='Ext-dataview-DataView-cfg-multiSelect'>    /**
</span>     * @member Ext.dataview.DataView
     * @cfg {Boolean} multiSelect
     * `true` to allow selection of more than one item at a time.
     * @removed 2.0.0 multiSelect is deprecated. Please use {@link Ext.mixin.Selectable#mode mode} instead
     */
    Ext.deprecateProperty(this, &#39;multiSelect&#39;, null, &quot;Ext.dataview.DataView.multiSelect has been removed&quot;);

<span id='Ext-dataview-DataView-cfg-overItemCls'>    /**
</span>     * @member Ext.dataview.DataView
     * @cfg {Boolean} overItemCls
     * A CSS class to apply to each item in the view on mouseover.
     * @removed 2.0.0
     */
    Ext.deprecateProperty(this, &#39;overItemCls&#39;, null, &quot;Ext.dataview.DataView.overItemCls has been removed&quot;);

<span id='Ext-dataview-DataView-cfg-selectedItemCls'>    /**
</span>     * @member Ext.dataview.DataView
     * @cfg {Boolean} selectedItemCls
     * A CSS class to apply to each selected item in the view.
     * @removed 2.0.0 Please use {@link #selectedCls selectedCls} instead
     */
    Ext.deprecateProperty(this, &#39;selectedItemCls&#39;, null, &quot;Ext.dataview.DataView.selectedItemCls has been removed&quot;);

<span id='Ext-dataview-DataView-cfg-simpleSelect'>    /**
</span>     * @member Ext.dataview.DataView
     * @cfg {Boolean} simpleSelect
     * `true` to enable multi-selection by clicking on multiple items without requiring
     * the user to hold Shift or Ctrl, `false` to force the user to hold Ctrl or Shift
     * to select more than on item.
     * @removed 2.0.0 Please use {@link Ext.mixin.Selectable#mode mode} instead
     */
    Ext.deprecateProperty(this, &#39;simpleSelect&#39;, null, &quot;Ext.dataview.DataView.simpleSelect has been removed&quot;);

<span id='Ext-dataview-DataView-cfg-singleSelect'>    /**
</span>     * @member Ext.dataview.DataView
     * @cfg {Boolean} singleSelect
     * `true` to allow selection of exactly one item at a time, `false` to allow no selection at all.
     * @removed 2.0.0 Please use {@link Ext.mixin.Selectable#mode mode} instead
     */
    Ext.deprecateProperty(this, &#39;singleSelect&#39;, null, &quot;Ext.dataview.DataView.singleSelect has been removed&quot;);

<span id='Ext-dataview-DataView-cfg-trackOver'>    /**
</span>     * @member Ext.dataview.DataView
     * @cfg {Boolean} trackOver
     * `true` to enable `mouseenter` and `mouseleave` events.
     * @removed 2.0.0
     */
    Ext.deprecateProperty(this, &#39;trackOver&#39;, null, &quot;Ext.dataview.DataView.trackOver has been removed&quot;);

    //&lt;/deprecated&gt;
});
</pre>
</body>
</html>
