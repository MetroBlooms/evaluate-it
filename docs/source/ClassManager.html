<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">//@tag foundation,core
//@define Ext.ClassManager
//@require Ext.Class

<span id='Ext-ClassManager'>/**
</span> * @class  Ext.ClassManager
 *
 * @author Jacky Nguyen &lt;jacky@sencha.com&gt;
 * @aside guide class_system
 * @aside video class-system
 *
 * Ext.ClassManager manages all classes and handles mapping from string class name to
 * actual class objects throughout the whole framework. It is not generally accessed directly, rather through
 * these convenient shorthands:
 *
 * - {@link Ext#define Ext.define}
 * - {@link Ext.ClassManager#create Ext.create}
 * - {@link Ext#widget Ext.widget}
 * - {@link Ext#getClass Ext.getClass}
 * - {@link Ext#getClassName Ext.getClassName}
 *
 * ## Basic syntax:
 *
 *     Ext.define(className, properties);
 *
 * in which `properties` is an object represent a collection of properties that apply to the class. See
 * {@link Ext.ClassManager#create} for more detailed instructions.
 *
 *     @example
 *     Ext.define(&#39;Person&#39;, {
 *          name: &#39;Unknown&#39;,
 *
 *          constructor: function(name) {
 *              if (name) {
 *                  this.name = name;
 *              }
 *
 *              return this;
 *          },
 *
 *          eat: function(foodType) {
 *              alert(&quot;I&#39;m eating: &quot; + foodType);
 *
 *              return this;
 *          }
 *     });
 *
 *     var aaron = new Person(&quot;Aaron&quot;);
 *     aaron.eat(&quot;Sandwich&quot;); // alert(&quot;I&#39;m eating: Sandwich&quot;);
 *
 * Ext.Class has a powerful set of extensible {@link Ext.Class#registerPreprocessor pre-processors} which takes care of
 * everything related to class creation, including but not limited to inheritance, mixins, configuration, statics, etc.
 *
 * ## Inheritance:
 *
 *     Ext.define(&#39;Developer&#39;, {
 *          extend: &#39;Person&#39;,
 *
 *          constructor: function(name, isGeek) {
 *              this.isGeek = isGeek;
 *
 *              // Apply a method from the parent class&#39; prototype
 *              this.callParent([name]);
 *
 *              return this;
 *
 *          },
 *
 *          code: function(language) {
 *              alert(&quot;I&#39;m coding in: &quot; + language);
 *
 *              this.eat(&quot;Bugs&quot;);
 *
 *              return this;
 *          }
 *     });
 *
 *     var jacky = new Developer(&quot;Jacky&quot;, true);
 *     jacky.code(&quot;JavaScript&quot;); // alert(&quot;I&#39;m coding in: JavaScript&quot;);
 *                               // alert(&quot;I&#39;m eating: Bugs&quot;);
 *
 * See {@link Ext.Base#callParent} for more details on calling superclass&#39; methods
 *
 * ## Mixins:
 *
 *     Ext.define(&#39;CanPlayGuitar&#39;, {
 *          playGuitar: function() {
 *             alert(&quot;F#...G...D...A&quot;);
 *          }
 *     });
 *
 *     Ext.define(&#39;CanComposeSongs&#39;, {
 *          composeSongs: function() { }
 *     });
 *
 *     Ext.define(&#39;CanSing&#39;, {
 *          sing: function() {
 *              alert(&quot;I&#39;m on the highway to hell...&quot;);
 *          }
 *     });
 *
 *     Ext.define(&#39;Musician&#39;, {
 *          extend: &#39;Person&#39;,
 *
 *          mixins: {
 *              canPlayGuitar: &#39;CanPlayGuitar&#39;,
 *              canComposeSongs: &#39;CanComposeSongs&#39;,
 *              canSing: &#39;CanSing&#39;
 *          }
 *     });
 *
 *     Ext.define(&#39;CoolPerson&#39;, {
 *          extend: &#39;Person&#39;,
 *
 *          mixins: {
 *              canPlayGuitar: &#39;CanPlayGuitar&#39;,
 *              canSing: &#39;CanSing&#39;
 *          },
 *
 *          sing: function() {
 *              alert(&quot;Ahem...&quot;);
 *
 *              this.mixins.canSing.sing.call(this);
 *
 *              alert(&quot;[Playing guitar at the same time...]&quot;);
 *
 *              this.playGuitar();
 *          }
 *     });
 *
 *     var me = new CoolPerson(&quot;Jacky&quot;);
 *
 *     me.sing(); // alert(&quot;Ahem...&quot;);
 *                // alert(&quot;I&#39;m on the highway to hell...&quot;);
 *                // alert(&quot;[Playing guitar at the same time...]&quot;);
 *                // alert(&quot;F#...G...D...A&quot;);
 *
 * ## Config:
 *
 *     Ext.define(&#39;SmartPhone&#39;, {
 *          config: {
 *              hasTouchScreen: false,
 *              operatingSystem: &#39;Other&#39;,
 *              price: 500
 *          },
 *
 *          isExpensive: false,
 *
 *          constructor: function(config) {
 *              this.initConfig(config);
 *
 *              return this;
 *          },
 *
 *          applyPrice: function(price) {
 *              this.isExpensive = (price &gt; 500);
 *
 *              return price;
 *          },
 *
 *          applyOperatingSystem: function(operatingSystem) {
 *              if (!(/^(iOS|Android|BlackBerry)$/i).test(operatingSystem)) {
 *                  return &#39;Other&#39;;
 *              }
 *
 *              return operatingSystem;
 *          }
 *     });
 *
 *     var iPhone = new SmartPhone({
 *          hasTouchScreen: true,
 *          operatingSystem: &#39;iOS&#39;
 *     });
 *
 *     iPhone.getPrice(); // 500;
 *     iPhone.getOperatingSystem(); // &#39;iOS&#39;
 *     iPhone.getHasTouchScreen(); // true;
 *
 *     iPhone.isExpensive; // false;
 *     iPhone.setPrice(600);
 *     iPhone.getPrice(); // 600
 *     iPhone.isExpensive; // true;
 *
 *     iPhone.setOperatingSystem(&#39;AlienOS&#39;);
 *     iPhone.getOperatingSystem(); // &#39;Other&#39;
 *
 * ## Statics:
 *
 *     Ext.define(&#39;Computer&#39;, {
 *          statics: {
 *              factory: function(brand) {
 *                 // &#39;this&#39; in static methods refer to the class itself
 *                  return new this(brand);
 *              }
 *          },
 *
 *          constructor: function() { }
 *     });
 *
 *     var dellComputer = Computer.factory(&#39;Dell&#39;);
 *
 * Also see {@link Ext.Base#statics} and {@link Ext.Base#self} for more details on accessing
 * static properties within class methods
 *
 * @singleton
 */
(function(Class, alias, arraySlice, arrayFrom, global) {
    //&lt;if nonBrowser&gt;
    var isNonBrowser = typeof window == &#39;undefined&#39;;
    //&lt;/if&gt;
    var Manager = Ext.ClassManager = {

<span id='Ext-ClassManager-property-classes'>        /**
</span>         * @property classes
         * @type Object
         * All classes which were defined through the ClassManager. Keys are the
         * name of the classes and the values are references to the classes.
         * @private
         */
        classes: {},

<span id='Ext-ClassManager-property-existCache'>        /**
</span>         * @private
         */
        existCache: {},

<span id='Ext-ClassManager-property-namespaceRewrites'>        /**
</span>         * @private
         */
        namespaceRewrites: [{
            from: &#39;Ext.&#39;,
            to: Ext
        }],

<span id='Ext-ClassManager-property-maps'>        /**
</span>         * @private
         */
        maps: {
            alternateToName: {},
            aliasToName: {},
            nameToAliases: {},
            nameToAlternates: {}
        },

<span id='Ext-ClassManager-property-enableNamespaceParseCache'>        /** @private */
</span>        enableNamespaceParseCache: true,

<span id='Ext-ClassManager-property-namespaceParseCache'>        /** @private */
</span>        namespaceParseCache: {},

<span id='Ext-ClassManager-property-instantiators'>        /** @private */
</span>        instantiators: [],

<span id='Ext-ClassManager-method-isCreated'>        /**
</span>         * Checks if a class has already been created.
         *
         * @param {String} className
         * @return {Boolean} exist
         */
        isCreated: function(className) {
            var existCache = this.existCache,
                i, ln, part, root, parts;

            //&lt;debug error&gt;
            if (typeof className != &#39;string&#39; || className.length &lt; 1) {
                throw new Error(&quot;[Ext.ClassManager] Invalid classname, must be a string and must not be empty&quot;);
            }
            //&lt;/debug&gt;

            if (this.classes[className] || existCache[className]) {
                return true;
            }

            root = global;
            parts = this.parseNamespace(className);

            for (i = 0, ln = parts.length; i &lt; ln; i++) {
                part = parts[i];

                if (typeof part != &#39;string&#39;) {
                    root = part;
                } else {
                    if (!root || !root[part]) {
                        return false;
                    }

                    root = root[part];
                }
            }

            existCache[className] = true;

            this.triggerCreated(className);

            return true;
        },

<span id='Ext-ClassManager-property-createdListeners'>        /**
</span>         * @private
         */
        createdListeners: [],

<span id='Ext-ClassManager-property-nameCreatedListeners'>        /**
</span>         * @private
         */
        nameCreatedListeners: {},

<span id='Ext-ClassManager-method-triggerCreated'>        /**
</span>         * @private
         */
        triggerCreated: function(className) {
            var listeners = this.createdListeners,
                nameListeners = this.nameCreatedListeners,
                alternateNames = this.maps.nameToAlternates[className],
                names = [className],
                i, ln, j, subLn, listener, name;

            for (i = 0,ln = listeners.length; i &lt; ln; i++) {
                listener = listeners[i];
                listener.fn.call(listener.scope, className);
            }

            if (alternateNames) {
                names.push.apply(names, alternateNames);
            }

            for (i = 0,ln = names.length; i &lt; ln; i++) {
                name = names[i];
                listeners = nameListeners[name];

                if (listeners) {
                    for (j = 0,subLn = listeners.length; j &lt; subLn; j++) {
                        listener = listeners[j];
                        listener.fn.call(listener.scope, name);
                    }
                    delete nameListeners[name];
                }
            }
        },

<span id='Ext-ClassManager-method-onCreated'>        /**
</span>         * @private
         */
        onCreated: function(fn, scope, className) {
            var listeners = this.createdListeners,
                nameListeners = this.nameCreatedListeners,
                listener = {
                    fn: fn,
                    scope: scope
                };

            if (className) {
                if (this.isCreated(className)) {
                    fn.call(scope, className);
                    return;
                }

                if (!nameListeners[className]) {
                    nameListeners[className] = [];
                }

                nameListeners[className].push(listener);
            }
            else {
                listeners.push(listener);
            }
        },

<span id='Ext-ClassManager-method-parseNamespace'>        /**
</span>         * Supports namespace rewriting.
         * @private
         */
        parseNamespace: function(namespace) {
            //&lt;debug error&gt;
            if (typeof namespace != &#39;string&#39;) {
                throw new Error(&quot;[Ext.ClassManager] Invalid namespace, must be a string&quot;);
            }
            //&lt;/debug&gt;

            var cache = this.namespaceParseCache;

            if (this.enableNamespaceParseCache) {
                if (cache.hasOwnProperty(namespace)) {
                    return cache[namespace];
                }
            }

            var parts = [],
                rewrites = this.namespaceRewrites,
                root = global,
                name = namespace,
                rewrite, from, to, i, ln;

            for (i = 0, ln = rewrites.length; i &lt; ln; i++) {
                rewrite = rewrites[i];
                from = rewrite.from;
                to = rewrite.to;

                if (name === from || name.substring(0, from.length) === from) {
                    name = name.substring(from.length);

                    if (typeof to != &#39;string&#39;) {
                        root = to;
                    } else {
                        parts = parts.concat(to.split(&#39;.&#39;));
                    }

                    break;
                }
            }

            parts.push(root);

            parts = parts.concat(name.split(&#39;.&#39;));

            if (this.enableNamespaceParseCache) {
                cache[namespace] = parts;
            }

            return parts;
        },

<span id='Ext-ClassManager-method-setNamespace'>        /**
</span>         * Creates a namespace and assign the `value` to the created object.
         *
         *     Ext.ClassManager.setNamespace(&#39;MyCompany.pkg.Example&#39;, someObject);
         *     alert(MyCompany.pkg.Example === someObject); // alerts true
         *
         * @param {String} name
         * @param {Mixed} value
         */
        setNamespace: function(name, value) {
            var root = global,
                parts = this.parseNamespace(name),
                ln = parts.length - 1,
                leaf = parts[ln],
                i, part;

            for (i = 0; i &lt; ln; i++) {
                part = parts[i];

                if (typeof part != &#39;string&#39;) {
                    root = part;
                } else {
                    if (!root[part]) {
                        root[part] = {};
                    }

                    root = root[part];
                }
            }

            root[leaf] = value;

            return root[leaf];
        },

<span id='Ext-ClassManager-method-createNamespaces'>        /**
</span>         * The new Ext.ns, supports namespace rewriting.
         * @private
         */
        createNamespaces: function() {
            var root = global,
                parts, part, i, j, ln, subLn;

            for (i = 0, ln = arguments.length; i &lt; ln; i++) {
                parts = this.parseNamespace(arguments[i]);

                for (j = 0, subLn = parts.length; j &lt; subLn; j++) {
                    part = parts[j];

                    if (typeof part != &#39;string&#39;) {
                        root = part;
                    } else {
                        if (!root[part]) {
                            root[part] = {};
                        }

                        root = root[part];
                    }
                }
            }

            return root;
        },

<span id='Ext-ClassManager-method-set'>        /**
</span>         * Sets a name reference to a class.
         *
         * @param {String} name
         * @param {Object} value
         * @return {Ext.ClassManager} this
         */
        set: function(name, value) {
            var me = this,
                maps = me.maps,
                nameToAlternates = maps.nameToAlternates,
                targetName = me.getName(value),
                alternates;

            me.classes[name] = me.setNamespace(name, value);

            if (targetName &amp;&amp; targetName !== name) {
                maps.alternateToName[name] = targetName;
                alternates = nameToAlternates[targetName] || (nameToAlternates[targetName] = []);
                alternates.push(name);
            }

            return this;
        },

<span id='Ext-ClassManager-method-get'>        /**
</span>         * Retrieve a class by its name.
         *
         * @param {String} name
         * @return {Ext.Class} class
         */
        get: function(name) {
            var classes = this.classes;

            if (classes[name]) {
                return classes[name];
            }

            var root = global,
                parts = this.parseNamespace(name),
                part, i, ln;

            for (i = 0, ln = parts.length; i &lt; ln; i++) {
                part = parts[i];

                if (typeof part != &#39;string&#39;) {
                    root = part;
                } else {
                    if (!root || !root[part]) {
                        return null;
                    }

                    root = root[part];
                }
            }

            return root;
        },

<span id='Ext-ClassManager-method-setAlias'>        /**
</span>         * Register the alias for a class.
         *
         * @param {Ext.Class/String} cls a reference to a class or a `className`.
         * @param {String} alias Alias to use when referring to this class.
         */
        setAlias: function(cls, alias) {
            var aliasToNameMap = this.maps.aliasToName,
                nameToAliasesMap = this.maps.nameToAliases,
                className;

            if (typeof cls == &#39;string&#39;) {
                className = cls;
            } else {
                className = this.getName(cls);
            }

            if (alias &amp;&amp; aliasToNameMap[alias] !== className) {
                //&lt;debug info&gt;
                if (aliasToNameMap[alias]) {
                    Ext.Logger.info(&quot;[Ext.ClassManager] Overriding existing alias: &#39;&quot; + alias + &quot;&#39; &quot; +
                        &quot;of: &#39;&quot; + aliasToNameMap[alias] + &quot;&#39; with: &#39;&quot; + className + &quot;&#39;. Be sure it&#39;s intentional.&quot;);
                }
                //&lt;/debug&gt;

                aliasToNameMap[alias] = className;
            }

            if (!nameToAliasesMap[className]) {
                nameToAliasesMap[className] = [];
            }

            if (alias) {
                Ext.Array.include(nameToAliasesMap[className], alias);
            }

            return this;
        },

<span id='Ext-ClassManager-method-addNameAliasMappings'>        /**
</span>         * Adds a batch of class name to alias mappings
         * @param {Object} aliases The set of mappings of the form
         * className : [values...]
         */
        addNameAliasMappings: function(aliases){
            var aliasToNameMap = this.maps.aliasToName,
                nameToAliasesMap = this.maps.nameToAliases,
                className, aliasList, alias, i;

            for (className in aliases) {
                aliasList = nameToAliasesMap[className] ||
                    (nameToAliasesMap[className] = []);

                for (i = 0; i &lt; aliases[className].length; i++) {
                    alias = aliases[className][i];
                    if (!aliasToNameMap[alias]) {
                        aliasToNameMap[alias] = className;
                        aliasList.push(alias);
                    }
                }

            }
            return this;
        },

<span id='Ext-ClassManager-method-addNameAlternateMappings'>        /**
</span>         *
         * @param {Object} alternates The set of mappings of the form
         * className : [values...]
         */
        addNameAlternateMappings: function(alternates) {
            var alternateToName = this.maps.alternateToName,
                nameToAlternates = this.maps.nameToAlternates,
                className, aliasList, alternate, i;

            for (className in alternates) {
                aliasList = nameToAlternates[className] ||
                    (nameToAlternates[className] = []);

                for (i  = 0; i &lt; alternates[className].length; i++) {
                    alternate = alternates[className];
                    if (!alternateToName[alternate]) {
                        alternateToName[alternate] = className;
                        aliasList.push(alternate);
                    }
                }

            }
            return this;
        },

<span id='Ext-ClassManager-method-getByAlias'>        /**
</span>         * Get a reference to the class by its alias.
         *
         * @param {String} alias
         * @return {Ext.Class} class
         */
        getByAlias: function(alias) {
            return this.get(this.getNameByAlias(alias));
        },

<span id='Ext-ClassManager-method-getNameByAlias'>        /**
</span>         * Get the name of a class by its alias.
         *
         * @param {String} alias
         * @return {String} className
         */
        getNameByAlias: function(alias) {
            return this.maps.aliasToName[alias] || &#39;&#39;;
        },

<span id='Ext-ClassManager-method-getNameByAlternate'>        /**
</span>         * Get the name of a class by its alternate name.
         *
         * @param {String} alternate
         * @return {String} className
         */
        getNameByAlternate: function(alternate) {
            return this.maps.alternateToName[alternate] || &#39;&#39;;
        },

<span id='Ext-ClassManager-method-getAliasesByName'>        /**
</span>         * Get the aliases of a class by the class name
         *
         * @param {String} name
         * @return {Array} aliases
         */
        getAliasesByName: function(name) {
            return this.maps.nameToAliases[name] || [];
        },

<span id='Ext-ClassManager-method-getName'>        /**
</span>         * Get the name of the class by its reference or its instance;
         * usually invoked by the shorthand {@link Ext#getClassName Ext.getClassName}
         *
         *     Ext.ClassManager.getName(Ext.Action); // returns &quot;Ext.Action&quot;
         *
         * @param {Ext.Class/Object} object
         * @return {String} className
         */
        getName: function(object) {
            return object &amp;&amp; object.$className || &#39;&#39;;
        },

<span id='Ext-ClassManager-method-getClass'>        /**
</span>         * Get the class of the provided object; returns null if it&#39;s not an instance
         * of any class created with Ext.define. This is usually invoked by the shorthand {@link Ext#getClass Ext.getClass}.
         *
         *     var component = new Ext.Component();
         *
         *     Ext.ClassManager.getClass(component); // returns Ext.Component
         *
         * @param {Object} object
         * @return {Ext.Class} class
         */
        getClass: function(object) {
            return object &amp;&amp; object.self || null;
        },

<span id='Ext-ClassManager-method-create'>        /**
</span>         * @private
         */
        create: function(className, data, createdFn) {
            //&lt;debug error&gt;
            if (typeof className != &#39;string&#39;) {
                throw new Error(&quot;[Ext.define] Invalid class name &#39;&quot; + className + &quot;&#39; specified, must be a non-empty string&quot;);
            }
            //&lt;/debug&gt;

            data.$className = className;

            return new Class(data, function() {
                var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors,
                    registeredPostprocessors = Manager.postprocessors,
                    index = 0,
                    postprocessors = [],
                    postprocessor, process, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;

                delete data.postprocessors;

                for (i = 0,ln = postprocessorStack.length; i &lt; ln; i++) {
                    postprocessor = postprocessorStack[i];

                    if (typeof postprocessor == &#39;string&#39;) {
                        postprocessor = registeredPostprocessors[postprocessor];
                        postprocessorProperties = postprocessor.properties;

                        if (postprocessorProperties === true) {
                            postprocessors.push(postprocessor.fn);
                        }
                        else if (postprocessorProperties) {
                            for (j = 0,subLn = postprocessorProperties.length; j &lt; subLn; j++) {
                                postprocessorProperty = postprocessorProperties[j];

                                if (data.hasOwnProperty(postprocessorProperty)) {
                                    postprocessors.push(postprocessor.fn);
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        postprocessors.push(postprocessor);
                    }
                }

                process = function(clsName, cls, clsData) {
                    postprocessor = postprocessors[index++];

                    if (!postprocessor) {
                        Manager.set(className, cls);

                        if (createdFn) {
                            createdFn.call(cls, cls);
                        }

                        Manager.triggerCreated(className);
                        return;
                    }

                    if (postprocessor.call(this, clsName, cls, clsData, process) !== false) {
                        process.apply(this, arguments);
                    }
                };

                process.call(Manager, className, this, data);
            });
        },

        createOverride: function(className, data, createdFn) {
            var overriddenClassName = data.override,
                requires = Ext.Array.from(data.requires);

            delete data.override;
            delete data.requires;

            this.existCache[className] = true;

            Ext.require(requires, function() {
                // Override the target class right after it&#39;s created
                this.onCreated(function() {
                    var overridenClass = this.get(overriddenClassName);
                    if (overridenClass.singleton) {
                        overridenClass.self.override(data);
                    }
                    else {
                        overridenClass.override(data);
                    }

                    if (createdFn) {
                        createdFn.call(overridenClass, overridenClass);
                    }

                    // This push the overridding file itself into Ext.Loader.history
                    // Hence if the target class never exists, the overriding file will
                    // never be included in the build
                    this.triggerCreated(className);
                }, this, overriddenClassName);
            }, this);

            return this;
        },

<span id='Ext-ClassManager-method-instantiateByAlias'>        /**
</span>         * Instantiate a class by its alias; usually invoked by the convenient shorthand {@link Ext#createByAlias Ext.createByAlias}
         * If {@link Ext.Loader} is {@link Ext.Loader#setConfig enabled} and the class has not been defined yet, it will
         * attempt to load the class via synchronous loading.
         *
         *     var window = Ext.ClassManager.instantiateByAlias(&#39;widget.window&#39;, { width: 600, height: 800 });
         *
         * @param {String} alias
         * @param {Mixed...} args Additional arguments after the alias will be passed to the class constructor.
         * @return {Object} instance
         */
        instantiateByAlias: function() {
            var alias = arguments[0],
                args = arraySlice.call(arguments),
                className = this.getNameByAlias(alias);

            if (!className) {
                className = this.maps.aliasToName[alias];

                //&lt;debug error&gt;
                if (!className) {
                    throw new Error(&quot;[Ext.createByAlias] Cannot create an instance of unrecognized alias: &quot; + alias);
                }
                //&lt;/debug&gt;

                //&lt;debug warn&gt;
                Ext.Logger.warn(&quot;[Ext.Loader] Synchronously loading &#39;&quot; + className + &quot;&#39;; consider adding &quot; +
                     &quot;Ext.require(&#39;&quot; + alias + &quot;&#39;) above Ext.onReady&quot;);
                //&lt;/debug&gt;

                Ext.syncRequire(className);
            }

            args[0] = className;

            return this.instantiate.apply(this, args);
        },

<span id='Ext-ClassManager-method-instantiate'>        /**
</span>         * Instantiate a class by either full name, alias or alternate name; usually invoked by the convenient
         * shorthand {@link Ext.ClassManager#create Ext.create}.
         *
         * If {@link Ext.Loader} is {@link Ext.Loader#setConfig enabled} and the class has not been defined yet, it will
         * attempt to load the class via synchronous loading.
         *
         * For example, all these three lines return the same result:
         *
         *     // alias
         *     var formPanel = Ext.create(&#39;widget.formpanel&#39;, { width: 600, height: 800 });
         *
         *     // alternate name
         *     var formPanel = Ext.create(&#39;Ext.form.FormPanel&#39;, { width: 600, height: 800 });
         *
         *     // full class name
         *     var formPanel = Ext.create(&#39;Ext.form.Panel&#39;, { width: 600, height: 800 });
         *
         * @param {String} name
         * @param {Mixed} args Additional arguments after the name will be passed to the class&#39; constructor.
         * @return {Object} instance
         */
        instantiate: function() {
            var name = arguments[0],
                args = arraySlice.call(arguments, 1),
                alias = name,
                possibleName, cls;

            if (typeof name != &#39;function&#39;) {
                //&lt;debug error&gt;
                if ((typeof name != &#39;string&#39; || name.length &lt; 1)) {
                    throw new Error(&quot;[Ext.create] Invalid class name or alias &#39;&quot; + name + &quot;&#39; specified, must be a non-empty string&quot;);
                }
                //&lt;/debug&gt;

                cls = this.get(name);
            }
            else {
                cls = name;
            }

            // No record of this class name, it&#39;s possibly an alias, so look it up
            if (!cls) {
                possibleName = this.getNameByAlias(name);

                if (possibleName) {
                    name = possibleName;

                    cls = this.get(name);
                }
            }

            // Still no record of this class name, it&#39;s possibly an alternate name, so look it up
            if (!cls) {
                possibleName = this.getNameByAlternate(name);

                if (possibleName) {
                    name = possibleName;

                    cls = this.get(name);
                }
            }

            // Still not existing at this point, try to load it via synchronous mode as the last resort
            if (!cls) {
                //&lt;debug warn&gt;
                //&lt;if nonBrowser&gt;
                !isNonBrowser &amp;&amp;
                //&lt;/if&gt;
                Ext.Logger.warn(&quot;[Ext.Loader] Synchronously loading &#39;&quot; + name + &quot;&#39;; consider adding &#39;&quot; +
                    ((possibleName) ? alias : name) + &quot;&#39; explicitly as a require of the corresponding class&quot;);
                //&lt;/debug&gt;

                Ext.syncRequire(name);

                cls = this.get(name);
            }

            //&lt;debug error&gt;
            if (!cls) {
                throw new Error(&quot;[Ext.create] Cannot create an instance of unrecognized class name / alias: &quot; + alias);
            }

            if (typeof cls != &#39;function&#39;) {
                throw new Error(&quot;[Ext.create] &#39;&quot; + name + &quot;&#39; is a singleton and cannot be instantiated&quot;);
            }
            //&lt;/debug&gt;

            return this.getInstantiator(args.length)(cls, args);
        },

<span id='Ext-ClassManager-method-dynInstantiate'>        /**
</span>         * @private
         * @param {String} name
         * @param {Array} args
         */
        dynInstantiate: function(name, args) {
            args = arrayFrom(args, true);
            args.unshift(name);

            return this.instantiate.apply(this, args);
        },

<span id='Ext-ClassManager-method-getInstantiator'>        /**
</span>         * @private
         * @param {Number} length
         */
        getInstantiator: function(length) {
            var instantiators = this.instantiators,
                instantiator;

            instantiator = instantiators[length];

            if (!instantiator) {
                var i = length,
                    args = [];

                for (i = 0; i &lt; length; i++) {
                    args.push(&#39;a[&#39; + i + &#39;]&#39;);
                }

                instantiator = instantiators[length] = new Function(&#39;c&#39;, &#39;a&#39;, &#39;return new c(&#39; + args.join(&#39;,&#39;) + &#39;)&#39;);
                //&lt;debug&gt;
                instantiator.displayName = &quot;Ext.ClassManager.instantiate&quot; + length;
                //&lt;/debug&gt;
            }

            return instantiator;
        },

<span id='Ext-ClassManager-property-postprocessors'>        /**
</span>         * @private
         */
        postprocessors: {},

<span id='Ext-ClassManager-property-defaultPostprocessors'>        /**
</span>         * @private
         */
        defaultPostprocessors: [],

<span id='Ext-ClassManager-method-registerPostprocessor'>        /**
</span>         * Register a post-processor function.
         * @private
         */
        registerPostprocessor: function(name, fn, properties, position, relativeTo) {
            if (!position) {
                position = &#39;last&#39;;
            }

            if (!properties) {
                properties = [name];
            }

            this.postprocessors[name] = {
                name: name,
                properties: properties || false,
                fn: fn
            };

            this.setDefaultPostprocessorPosition(name, position, relativeTo);

            return this;
        },

<span id='Ext-ClassManager-method-setDefaultPostprocessors'>        /**
</span>         * Set the default post processors array stack which are applied to every class.
         *
         * @private
         * @param {String/Array} postprocessors The name of a registered post processor or an array of registered names.
         * @return {Ext.ClassManager} this
         */
        setDefaultPostprocessors: function(postprocessors) {
            this.defaultPostprocessors = arrayFrom(postprocessors);

            return this;
        },

<span id='Ext-ClassManager-method-setDefaultPostprocessorPosition'>        /**
</span>         * Insert this post-processor at a specific position in the stack, optionally relative to
         * any existing post-processor
         *
         * @private
         * @param {String} name The post-processor name. Note that it needs to be registered with
         * {@link Ext.ClassManager#registerPostprocessor} before this
         * @param {String} offset The insertion position. Four possible values are:
         * &#39;first&#39;, &#39;last&#39;, or: &#39;before&#39;, &#39;after&#39; (relative to the name provided in the third argument)
         * @param {String} relativeName
         * @return {Ext.ClassManager} this
         */
        setDefaultPostprocessorPosition: function(name, offset, relativeName) {
            var defaultPostprocessors = this.defaultPostprocessors,
                index;

            if (typeof offset == &#39;string&#39;) {
                if (offset === &#39;first&#39;) {
                    defaultPostprocessors.unshift(name);

                    return this;
                }
                else if (offset === &#39;last&#39;) {
                    defaultPostprocessors.push(name);

                    return this;
                }

                offset = (offset === &#39;after&#39;) ? 1 : -1;
            }

            index = Ext.Array.indexOf(defaultPostprocessors, relativeName);

            if (index !== -1) {
                Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
            }

            return this;
        },

<span id='Ext-ClassManager-method-getNamesByExpression'>        /**
</span>         * Converts a string expression to an array of matching class names. An expression can either refers to class aliases
         * or class names. Expressions support wildcards:
         *
         *      // returns [&#39;Ext.window.Window&#39;]
         *     var window = Ext.ClassManager.getNamesByExpression(&#39;widget.window&#39;);
         *
         *     // returns [&#39;widget.panel&#39;, &#39;widget.window&#39;, ...]
         *     var allWidgets = Ext.ClassManager.getNamesByExpression(&#39;widget.*&#39;);
         *
         *     // returns [&#39;Ext.data.Store&#39;, &#39;Ext.data.ArrayProxy&#39;, ...]
         *     var allData = Ext.ClassManager.getNamesByExpression(&#39;Ext.data.*&#39;);
         *
         * @param {String} expression
         * @return {Array} classNames
         */
        getNamesByExpression: function(expression) {
            var nameToAliasesMap = this.maps.nameToAliases,
                names = [],
                name, alias, aliases, possibleName, regex, i, ln;

            //&lt;debug error&gt;
            if (typeof expression != &#39;string&#39; || expression.length &lt; 1) {
                throw new Error(&quot;[Ext.ClassManager.getNamesByExpression] Expression &quot; + expression + &quot; is invalid, must be a non-empty string&quot;);
            }
            //&lt;/debug&gt;

            if (expression.indexOf(&#39;*&#39;) !== -1) {
                expression = expression.replace(/\*/g, &#39;(.*?)&#39;);
                regex = new RegExp(&#39;^&#39; + expression + &#39;$&#39;);

                for (name in nameToAliasesMap) {
                    if (nameToAliasesMap.hasOwnProperty(name)) {
                        aliases = nameToAliasesMap[name];

                        if (name.search(regex) !== -1) {
                            names.push(name);
                        }
                        else {
                            for (i = 0, ln = aliases.length; i &lt; ln; i++) {
                                alias = aliases[i];

                                if (alias.search(regex) !== -1) {
                                    names.push(name);
                                    break;
                                }
                            }
                        }
                    }
                }

            } else {
                possibleName = this.getNameByAlias(expression);

                if (possibleName) {
                    names.push(possibleName);
                } else {
                    possibleName = this.getNameByAlternate(expression);

                    if (possibleName) {
                        names.push(possibleName);
                    } else {
                        names.push(expression);
                    }
                }
            }

            return names;
        }
    };

    //&lt;feature classSystem.alias&gt;
<span id='Ext-Class-cfg-alias'>    /**
</span>     * @cfg {String[]} alias
     * @member Ext.Class
     * List of short aliases for class names.  Most useful for defining xtypes for widgets:
     *
     *     Ext.define(&#39;MyApp.CoolPanel&#39;, {
     *         extend: &#39;Ext.panel.Panel&#39;,
     *         alias: [&#39;widget.coolpanel&#39;],
     *
     *         config: {
     *             html : &#39;Yeah!&#39;
     *         }
     *     });
     *
     *     // Using Ext.create
     *     Ext.create(&#39;widget.coolpanel&#39;);
     *
     *     // Using the shorthand for widgets and in xtypes
     *     Ext.widget(&#39;panel&#39;, {
     *         items: [
     *             {xtype: &#39;coolpanel&#39;, html: &#39;Foo&#39;},
     *             {xtype: &#39;coolpanel&#39;, html: &#39;Bar&#39;}
     *         ]
     *     });
     *
     * For {@link Ext.Component}, you can also use the {@link Ext.Component#xtype} property.
     */
<span id='Ext-Component-cfg-xtype'>    /**
</span>     * @cfg {String[]} xtype
     * @member Ext.Component
     * List of xtypes for {@link Ext.Component}. XTypes must not contain periods.
     *
     *     Ext.define(&#39;MyApp.CoolPanel&#39;, {
     *         extend: &#39;Ext.panel.Panel&#39;,
     *         xtype: &#39;coolpanel&#39;,
     *
     *         config: {
     *             html : &#39;Yeah!&#39;
     *         }
     *     });
     *
     *     // Using Ext.create
     *     Ext.create(&#39;widget.coolpanel&#39;);
     *
     *     // Using the shorthand for widgets and in xtypes
     *     Ext.widget(&#39;panel&#39;, {
     *         items: [
     *             {xtype: &#39;coolpanel&#39;, html: &#39;Foo&#39;},
     *             {xtype: &#39;coolpanel&#39;, html: &#39;Bar&#39;}
     *         ]
     *     });
     */
    Manager.registerPostprocessor(&#39;alias&#39;, function(name, cls, data) {
        var aliases = data.alias,
            i, ln;

        for (i = 0,ln = aliases.length; i &lt; ln; i++) {
            alias = aliases[i];

            this.setAlias(cls, alias);
        }

    }, [&#39;xtype&#39;, &#39;alias&#39;]);
    //&lt;/feature&gt;

    //&lt;feature classSystem.singleton&gt;
<span id='Ext-Class-cfg-singleton'>    /**
</span>     * @cfg {Boolean} singleton
     * @member Ext.Class
     * When set to true, the class will be instantiated as singleton.  For example:
     *
     *     Ext.define(&#39;Logger&#39;, {
     *         singleton: true,
     *         log: function(msg) {
     *             console.log(msg);
     *         }
     *     });
     *
     *     Logger.log(&#39;Hello&#39;);
     */
    Manager.registerPostprocessor(&#39;singleton&#39;, function(name, cls, data, fn) {
        fn.call(this, name, new cls(), data);
        return false;
    });
    //&lt;/feature&gt;

    //&lt;feature classSystem.alternateClassName&gt;
<span id='Ext-Class-cfg-alternateClassName'>    /**
</span>     * @cfg {String/String[]} alternateClassName
     * @member Ext.Class
     * Defines alternate names for this class.  For example:
     *
     *     @example
     *     Ext.define(&#39;Developer&#39;, {
     *         alternateClassName: [&#39;Coder&#39;, &#39;Hacker&#39;],
     *         code: function(msg) {
     *             alert(&#39;Typing... &#39; + msg);
     *         }
     *     });
     *
     *     var joe = Ext.create(&#39;Developer&#39;);
     *     joe.code(&#39;stackoverflow&#39;);
     *
     *     var rms = Ext.create(&#39;Hacker&#39;);
     *     rms.code(&#39;hack hack&#39;);
     */
    Manager.registerPostprocessor(&#39;alternateClassName&#39;, function(name, cls, data) {
        var alternates = data.alternateClassName,
            i, ln, alternate;

        if (!(alternates instanceof Array)) {
            alternates = [alternates];
        }

        for (i = 0, ln = alternates.length; i &lt; ln; i++) {
            alternate = alternates[i];

            //&lt;debug error&gt;
            if (typeof alternate != &#39;string&#39;) {
                throw new Error(&quot;[Ext.define] Invalid alternate of: &#39;&quot; + alternate + &quot;&#39; for class: &#39;&quot; + name + &quot;&#39;; must be a valid string&quot;);
            }
            //&lt;/debug&gt;

            this.set(alternate, cls);
        }
    });
    //&lt;/feature&gt;

    Ext.apply(Ext, {
<span id='Ext-method-create'>        /**
</span>         * Instantiate a class by either full name, alias or alternate name.
         *
         * If {@link Ext.Loader} is {@link Ext.Loader#setConfig enabled} and the class has not been defined yet, it will
         * attempt to load the class via synchronous loading.
         *
         * For example, all these three lines return the same result:
         *
         *     // alias
         *     var formPanel = Ext.create(&#39;widget.formpanel&#39;, { width: 600, height: 800 });
         *
         *     // alternate name
         *     var formPanel = Ext.create(&#39;Ext.form.FormPanel&#39;, { width: 600, height: 800 });
         *
         *     // full class name
         *     var formPanel = Ext.create(&#39;Ext.form.Panel&#39;, { width: 600, height: 800 });
         *
         * @param {String} name
         * @param {Mixed} args Additional arguments after the name will be passed to the class&#39; constructor.
         * @return {Object} instance
         * @member Ext
         */
        create: alias(Manager, &#39;instantiate&#39;),

<span id='Ext-method-widget'>        /**
</span>         * Convenient shorthand to create a widget by its xtype, also see {@link Ext.ClassManager#instantiateByAlias}
         *
         *     var button = Ext.widget(&#39;button&#39;); // Equivalent to Ext.create(&#39;widget.button&#39;)
         *     var panel = Ext.widget(&#39;panel&#39;); // Equivalent to Ext.create(&#39;widget.panel&#39;)
         *
         * @member Ext
         * @method widget
         * @param {String} name
         * @return {Object} instance
         */
        widget: function(name) {
            var args = arraySlice.call(arguments);
            args[0] = &#39;widget.&#39; + name;

            return Manager.instantiateByAlias.apply(Manager, args);
        },

<span id='Ext-method-createByAlias'>        /**
</span>         * Convenient shorthand, see {@link Ext.ClassManager#instantiateByAlias}.
         * @member Ext
         * @method createByAlias
         * @param {String} alias
         * @param {Mixed...} args Additional arguments after the alias will be passed to the class constructor.
         * @return {Object} instance
         */
        createByAlias: alias(Manager, &#39;instantiateByAlias&#39;),

<span id='Ext-method-define'>        /**
</span>         * Defines a class or override. A basic class is defined like this:
         *
         *      Ext.define(&#39;My.awesome.Class&#39;, {
         *          someProperty: &#39;something&#39;,
         *
         *          someMethod: function(s) {
         *              console.log(s + this.someProperty);
         *          }
         *      });
         *
         *      var obj = new My.awesome.Class();
         *
         *      obj.someMethod(&#39;Say &#39;); // logs &#39;Say something&#39; to the console
         *
         * To defines an override, include the `override` property. The content of an
         * override is aggregated with the specified class in order to extend or modify
         * that class. This can be as simple as setting default property values or it can
         * extend and/or replace methods. This can also extend the statics of the class.
         *
         * One use for an override is to break a large class into manageable pieces.
         *
         *      // File: /src/app/Panel.js
         *      Ext.define(&#39;My.app.Panel&#39;, {
         *          extend: &#39;Ext.panel.Panel&#39;,
         *          requires: [
         *              &#39;My.app.PanelPart2&#39;,
         *              &#39;My.app.PanelPart3&#39;
         *          ],
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls Ext.panel.Panel&#39;s constructor
         *              // ...
         *          },
         *
         *          statics: {
         *              method: function () {
         *                  return &#39;abc&#39;;
         *              }
         *          }
         *      });
         *
         *      // File: /src/app/PanelPart2.js
         *      Ext.define(&#39;My.app.PanelPart2&#39;, {
         *          override: &#39;My.app.Panel&#39;,
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls My.app.Panel&#39;s constructor
         *              // ...
         *          }
         *      });
         *
         * Another use for an override is to provide optional parts of classes that can be
         * independently required. In this case, the class may even be unaware of the
         * override altogether.
         *
         *      Ext.define(&#39;My.ux.CoolTip&#39;, {
         *          override: &#39;Ext.tip.ToolTip&#39;,
         *
         *          constructor: function (config) {
         *              this.callParent(arguments); // calls Ext.tip.ToolTip&#39;s constructor
         *              // ...
         *          }
         *      });
         *
         * The above override can now be required as normal.
         *
         *      Ext.define(&#39;My.app.App&#39;, {
         *          requires: [
         *              &#39;My.ux.CoolTip&#39;
         *          ]
         *      });
         *
         * Overrides can also contain statics:
         *
         *      Ext.define(&#39;My.app.BarMod&#39;, {
         *          override: &#39;Ext.foo.Bar&#39;,
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x * 2]); // call Ext.foo.Bar.method
         *              }
         *          }
         *      });
         *
         * __IMPORTANT:__ An override is only included in a build if the class it overrides is
         * required. Otherwise, the override, like the target class, is not included.
         *
         * @param {String} className The class name to create in string dot-namespaced format, for example:
         * &#39;My.very.awesome.Class&#39;, &#39;FeedViewer.plugin.CoolPager&#39;
         *
         * It is highly recommended to follow this simple convention:
         *  - The root and the class name are &#39;CamelCased&#39;
         *  - Everything else is lower-cased
         *
         * @param {Object} data The key - value pairs of properties to apply to this class. Property names can be of
         * any valid strings, except those in the reserved listed below:
         *
         *  - `mixins`
         *  - `statics`
         *  - `config`
         *  - `alias`
         *  - `xtype` (for {@link Ext.Component}s only)
         *  - `self`
         *  - `singleton`
         *  - `alternateClassName`
         *  - `override`
         *
         * @param {Function} [createdFn] Optional callback to execute after the class (or override)
         * is created. The execution scope (`this`) will be the newly created class itself.
         * @return {Ext.Base}
         *
         * @member Ext
         * @method define
         */
        define: function (className, data, createdFn) {
            if (&#39;override&#39; in data) {
                return Manager.createOverride.apply(Manager, arguments);
            }

            return Manager.create.apply(Manager, arguments);
        },

<span id='Ext-method-getClassName'>        /**
</span>         * Convenient shorthand for {@link Ext.ClassManager#getName}.
         * @member Ext
         * @method getClassName
         * @inheritdoc Ext.ClassManager#getName
         */
        getClassName: alias(Manager, &#39;getName&#39;),

<span id='Ext-method-getDisplayName'>        /**
</span>         * Returns the display name for object.  This name is looked for in order from the following places:
         *
         * - `displayName` field of the object.
         * - `$name` and `$class` fields of the object.
         * - &#39;$className` field of the object.
         *
         * This method is used by {@link Ext.Logger#log} to display information about objects.
         *
         * @param {Mixed} [object] The object who&#39;s display name to determine.
         * @return {String} The determined display name, or &quot;Anonymous&quot; if none found.
         * @member Ext
         */
        getDisplayName: function(object) {
            if (object) {
                if (object.displayName) {
                    return object.displayName;
                }

                if (object.$name &amp;&amp; object.$class) {
                    return Ext.getClassName(object.$class) + &#39;#&#39; + object.$name;
                }

                if (object.$className) {
                    return object.$className;
                }
            }

            return &#39;Anonymous&#39;;
        },

<span id='Ext-method-getClass'>        /**
</span>         * Convenient shorthand, see {@link Ext.ClassManager#getClass}.
         * @member Ext
         * @method getClass
         */
        getClass: alias(Manager, &#39;getClass&#39;),

<span id='Ext-method-namespace'>        /**
</span>         * Creates namespaces to be used for scoping variables and classes so that they are not global.
         * Specifying the last node of a namespace implicitly creates all other nodes. Usage:
         *
         *     Ext.namespace(&#39;Company&#39;, &#39;Company.data&#39;);
         *
         *      // equivalent and preferable to the above syntax
         *     Ext.namespace(&#39;Company.data&#39;);
         *
         *     Company.Widget = function() {
         *         // ...
         *     };
         *
         *     Company.data.CustomStore = function(config) {
         *         // ...
         *     };
         *
         * @param {String} namespace1
         * @param {String} namespace2
         * @param {String} etc
         * @return {Object} The namespace object. If multiple arguments are passed, this will be the last namespace created.
         * @member Ext
         * @method namespace
         */
        namespace: alias(Manager, &#39;createNamespaces&#39;)
    });

<span id='Ext-method-createWidget'>    /**
</span>     * Old name for {@link Ext#widget}.
     * @deprecated 2.0.0 Please use {@link Ext#widget} instead.
     * @method createWidget
     * @member Ext
     */
    Ext.createWidget = Ext.widget;

<span id='Ext-method-ns'>    /**
</span>     * Convenient alias for {@link Ext#namespace Ext.namespace}.
     * @member Ext
     * @method ns
     */
    Ext.ns = Ext.namespace;

    Class.registerPreprocessor(&#39;className&#39;, function(cls, data) {
        if (data.$className) {
            cls.$className = data.$className;
            //&lt;debug&gt;
            cls.displayName = cls.$className;
            //&lt;/debug&gt;
        }
    }, true, &#39;first&#39;);

    Class.registerPreprocessor(&#39;alias&#39;, function(cls, data) {
        var prototype = cls.prototype,
            xtypes = arrayFrom(data.xtype),
            aliases = arrayFrom(data.alias),
            widgetPrefix = &#39;widget.&#39;,
            widgetPrefixLength = widgetPrefix.length,
            xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []),
            xtypesMap = Ext.merge({}, prototype.xtypesMap || {}),
            i, ln, alias, xtype;

        for (i = 0,ln = aliases.length; i &lt; ln; i++) {
            alias = aliases[i];

            //&lt;debug error&gt;
            if (typeof alias != &#39;string&#39; || alias.length &lt; 1) {
                throw new Error(&quot;[Ext.define] Invalid alias of: &#39;&quot; + alias + &quot;&#39; for class: &#39;&quot; + name + &quot;&#39;; must be a valid string&quot;);
            }
            //&lt;/debug&gt;

            if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
                xtype = alias.substring(widgetPrefixLength);
                Ext.Array.include(xtypes, xtype);
            }
        }

        cls.xtype = data.xtype = xtypes[0];
        data.xtypes = xtypes;

        for (i = 0,ln = xtypes.length; i &lt; ln; i++) {
            xtype = xtypes[i];

            if (!xtypesMap[xtype]) {
                xtypesMap[xtype] = true;
                xtypesChain.push(xtype);
            }
        }

        data.xtypesChain = xtypesChain;
        data.xtypesMap = xtypesMap;

        Ext.Function.interceptAfter(data, &#39;onClassCreated&#39;, function() {
            var mixins = prototype.mixins,
                key, mixin;

            for (key in mixins) {
                if (mixins.hasOwnProperty(key)) {
                    mixin = mixins[key];

                    xtypes = mixin.xtypes;

                    if (xtypes) {
                        for (i = 0,ln = xtypes.length; i &lt; ln; i++) {
                            xtype = xtypes[i];

                            if (!xtypesMap[xtype]) {
                                xtypesMap[xtype] = true;
                                xtypesChain.push(xtype);
                            }
                        }
                    }
                }
            }
        });

        for (i = 0,ln = xtypes.length; i &lt; ln; i++) {
            xtype = xtypes[i];

            //&lt;debug error&gt;
            if (typeof xtype != &#39;string&#39; || xtype.length &lt; 1) {
                throw new Error(&quot;[Ext.define] Invalid xtype of: &#39;&quot; + xtype + &quot;&#39; for class: &#39;&quot; + name + &quot;&#39;; must be a valid non-empty string&quot;);
            }
            //&lt;/debug&gt;

            Ext.Array.include(aliases, widgetPrefix + xtype);
        }

        data.alias = aliases;

    }, [&#39;xtype&#39;, &#39;alias&#39;]);

})(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global);
</pre>
</body>
</html>
