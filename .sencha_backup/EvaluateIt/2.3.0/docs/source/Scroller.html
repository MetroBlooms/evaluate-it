<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-scroll-Scroller'>/**
</span> * @class Ext.scroll.Scroller
 * @author Jacky Nguyen &lt;jacky@sencha.com&gt;
 *
 * Momentum scrolling is one of the most important part of the framework&#39;s UI layer. In Sencha Touch there are
 * several scroller implementations so we can have the best performance on all mobile devices and browsers.
 *
 * Scroller settings can be changed using the {@link Ext.Container#scrollable scrollable} configuration in
 * {@link Ext.Container}. Anything you pass to that method will be passed to the scroller when it is
 * instantiated in your container.
 *
 * Please note that the {@link Ext.Container#getScrollable} method returns an instance of {@link Ext.scroll.View}.
 * So if you need to get access to the scroller after your container has been instantiated, you must use the
 * {@link Ext.scroll.View#getScroller} method.
 *
 *     // lets assume container is a container you have
 *     // created which is scrollable
 *     container.getScrollable().getScroller().setFps(10);
 *
 * ## Example
 *
 * Here is a simple example of how to adjust the scroller settings when using a {@link Ext.Container} (or anything
 * that extends it).
 *
 *     @example
 *     var container = Ext.create(&#39;Ext.Container&#39;, {
 *         fullscreen: true,
 *         html: &#39;This container is scrollable!&#39;,
 *         scrollable: {
 *             direction: &#39;vertical&#39;
 *         }
 *     });
 *
 * As you can see, we are passing the {@link #direction} configuration into the scroller instance in our container.
 *
 * You can pass any of the configs below in that {@link Ext.Container#scrollable scrollable} configuration and it will
 * just work.
 *
 * Go ahead and try it in the live code editor above!
 */
Ext.define(&#39;Ext.scroll.Scroller&#39;, {

    extend: &#39;Ext.Evented&#39;,

    requires: [
        &#39;Ext.fx.easing.BoundMomentum&#39;,
        &#39;Ext.fx.easing.EaseOut&#39;,
        &#39;Ext.util.Translatable&#39;
    ],

<span id='Ext-scroll-Scroller-event-maxpositionchange'>    /**
</span>     * @event maxpositionchange
     * Fires whenever the maximum position has changed.
     * @param {Ext.scroll.Scroller} this
     * @param {Number} maxPosition The new maximum position.
     */

<span id='Ext-scroll-Scroller-event-refresh'>    /**
</span>     * @event refresh
     * Fires whenever the Scroller is refreshed.
     * @param {Ext.scroll.Scroller} this
     */

<span id='Ext-scroll-Scroller-event-scrollstart'>    /**
</span>     * @event scrollstart
     * Fires whenever the scrolling is started.
     * @param {Ext.scroll.Scroller} this
     * @param {Number} x The current x position.
     * @param {Number} y The current y position.
     */

<span id='Ext-scroll-Scroller-event-scrollend'>    /**
</span>     * @event scrollend
     * Fires whenever the scrolling is ended.
     * @param {Ext.scroll.Scroller} this
     * @param {Number} x The current x position.
     * @param {Number} y The current y position.
     */

<span id='Ext-scroll-Scroller-event-scroll'>    /**
</span>     * @event scroll
     * Fires whenever the Scroller is scrolled.
     * @param {Ext.scroll.Scroller} this
     * @param {Number} x The new x position.
     * @param {Number} y The new y position.
     */

    config: {
<span id='Ext-scroll-Scroller-cfg-element'>        /**
</span>         * @cfg element
         * @private
         */
        element: null,

<span id='Ext-scroll-Scroller-cfg-direction'>        /**
</span>         * @cfg {String} direction
         * Possible values: &#39;auto&#39;, &#39;vertical&#39;, &#39;horizontal&#39;, or &#39;both&#39;.
         * @accessor
         */
        direction: &#39;auto&#39;,

<span id='Ext-scroll-Scroller-cfg-fps'>        /**
</span>         * @cfg fps
         * @private
         */
        fps: &#39;auto&#39;,

<span id='Ext-scroll-Scroller-cfg-disabled'>        /**
</span>         * @cfg {Boolean} disabled
         * Whether or not this component is disabled.
         * @accessor
         */
        disabled: null,

<span id='Ext-scroll-Scroller-cfg-directionLock'>        /**
</span>         * @cfg {Boolean} directionLock
         * `true` to lock the direction of the scroller when the user starts scrolling.
         * This is useful when putting a scroller inside a scroller or a {@link Ext.Carousel}.
         * @accessor
         */
        directionLock: false,

<span id='Ext-scroll-Scroller-cfg-momentumEasing'>        /**
</span>         * @cfg {Object} momentumEasing
         * A valid config for {@link Ext.fx.easing.BoundMomentum}. The default value is:
         *
         *     {
         *         momentum: {
         *             acceleration: 30,
         *             friction: 0.5
         *         },
         *         bounce: {
         *             acceleration: 30,
         *             springTension: 0.3
         *         }
         *     }
         *
         * Note that supplied object will be recursively merged with the default object. For example, you can simply
         * pass this to change the momentum acceleration only:
         *
         *     {
         *         momentum: {
         *             acceleration: 10
         *         }
         *     }
         *
         * @accessor
         */
        momentumEasing: {
            momentum: {
                acceleration: 30,
                friction: 0.5
            },

            bounce: {
                acceleration: 30,
                springTension: 0.3
            },

            minVelocity: 1
        },

<span id='Ext-scroll-Scroller-cfg-bounceEasing'>        /**
</span>         * @cfg bounceEasing
         * @private
         */
        bounceEasing: {
            duration: 400
        },

<span id='Ext-scroll-Scroller-cfg-outOfBoundRestrictFactor'>        /**
</span>         * @cfg outOfBoundRestrictFactor
         * @private
         */
        outOfBoundRestrictFactor: 0.5,

<span id='Ext-scroll-Scroller-cfg-startMomentumResetTime'>        /**
</span>         * @cfg startMomentumResetTime
         * @private
         */
        startMomentumResetTime: 300,

<span id='Ext-scroll-Scroller-cfg-maxAbsoluteVelocity'>        /**
</span>         * @cfg maxAbsoluteVelocity
         * @private
         */
        maxAbsoluteVelocity: 6,

<span id='Ext-scroll-Scroller-cfg-containerSize'>        /**
</span>         * @cfg containerSize
         * @private
         */
        containerSize: &#39;auto&#39;,

<span id='Ext-scroll-Scroller-cfg-size'>        /**
</span>         * @cfg size
         * @private
         */
        size: &#39;auto&#39;,

<span id='Ext-scroll-Scroller-cfg-autoRefresh'>        /**
</span>         * @cfg autoRefresh
         * @private
         */
        autoRefresh: true,

<span id='Ext-scroll-Scroller-cfg-initialOffset'>        /**
</span>         * @cfg {Object/Number} initialOffset
         * The initial scroller position.  When specified as Number,
         * both x and y will be set to that value.
         */
        initialOffset: {
            x: 0,
            y: 0
        },

<span id='Ext-scroll-Scroller-cfg-slotSnapSize'>        /**
</span>         * @cfg {Number/Object} slotSnapSize
         * The size of each slot to snap to in &#39;px&#39;, can be either an object with `x` and `y` values, i.e:
         *
         *      {
         *          x: 50,
         *          y: 100
         *      }
         *
         * or a number value to be used for both directions. For example, a value of `50` will be treated as:
         *
         *      {
         *          x: 50,
         *          y: 50
         *      }
         *
         * @accessor
         */
        slotSnapSize: {
            x: 0,
            y: 0
        },

<span id='Ext-scroll-Scroller-cfg-slotSnapOffset'>        /**
</span>         * @cfg slotSnapOffset
         * @private
         */
        slotSnapOffset: {
            x: 0,
            y: 0
        },

<span id='Ext-scroll-Scroller-cfg-slotSnapEasing'>        slotSnapEasing: {
</span>            duration: 150
        },

<span id='Ext-scroll-Scroller-cfg-translatable'>        translatable: {
</span>            translationMethod: &#39;auto&#39;,
            useWrapper: false
        }
    },

<span id='Ext-scroll-Scroller-property-cls'>    cls: Ext.baseCSSPrefix + &#39;scroll-scroller&#39;,
</span>
<span id='Ext-scroll-Scroller-property-containerCls'>    containerCls: Ext.baseCSSPrefix + &#39;scroll-container&#39;,
</span>
<span id='Ext-scroll-Scroller-property-dragStartTime'>    dragStartTime: 0,
</span>
<span id='Ext-scroll-Scroller-property-dragEndTime'>    dragEndTime: 0,
</span>
<span id='Ext-scroll-Scroller-property-isDragging'>    isDragging: false,
</span>
<span id='Ext-scroll-Scroller-property-isAnimating'>    isAnimating: false,
</span>
<span id='Ext-scroll-Scroller-method-constructor'>    /**
</span>     * @private
     * @constructor
     * @chainable
     */
    constructor: function(config) {
        var element = config &amp;&amp; config.element;

        this.listeners = {
            scope: this,
            touchstart: &#39;onTouchStart&#39;,
            touchend: &#39;onTouchEnd&#39;,
            dragstart: &#39;onDragStart&#39;,
            drag: &#39;onDrag&#39;,
            dragend: &#39;onDragEnd&#39;
        };

        this.minPosition = { x: 0, y: 0 };

        this.startPosition = { x: 0, y: 0 };

        this.position = { x: 0, y: 0 };

        this.velocity = { x: 0, y: 0 };

        this.isAxisEnabledFlags = { x: false, y: false };

        this.flickStartPosition = { x: 0, y: 0 };

        this.flickStartTime = { x: 0, y: 0 };

        this.lastDragPosition = { x: 0, y: 0 };

        this.dragDirection = { x: 0, y: 0};

        this.initialConfig = config;

        if (element) {
            this.setElement(element);
        }

        return this;
    },

<span id='Ext-scroll-Scroller-method-applyElement'>    /**
</span>     * @private
     */
    applyElement: function(element) {
        if (!element) {
            return;
        }

        return Ext.get(element);
    },

<span id='Ext-scroll-Scroller-method-updateElement'>    /**
</span>     * @private
     * @chainable
     */
    updateElement: function(element) {
        this.initialize();

        if (!this.FixedHBoxStretching) {
            element.addCls(this.cls);
        }

        if (!this.getDisabled()) {
            this.attachListeneners();
        }

        this.onConfigUpdate([&#39;containerSize&#39;, &#39;size&#39;], &#39;refreshMaxPosition&#39;);

        this.on(&#39;maxpositionchange&#39;, &#39;snapToBoundary&#39;);
        this.on(&#39;minpositionchange&#39;, &#39;snapToBoundary&#39;);

        return this;
    },

<span id='Ext-scroll-Scroller-method-applyTranslatable'>    applyTranslatable: function(config, translatable) {
</span>        return Ext.factory(config, Ext.util.Translatable, translatable);
    },

<span id='Ext-scroll-Scroller-method-updateTranslatable'>    updateTranslatable: function(translatable) {
</span>        translatable.setConfig({
            element: this.getElement(),
            listeners: {
                animationframe: &#39;onAnimationFrame&#39;,
                animationend: &#39;onAnimationEnd&#39;,
                scope: this
            }
        });
    },

<span id='Ext-scroll-Scroller-method-updateFps'>    updateFps: function(fps) {
</span>        if (fps !== &#39;auto&#39;) {
            this.getTranslatable().setFps(fps);
        }
    },

<span id='Ext-scroll-Scroller-method-attachListeneners'>    /**
</span>     * @private
     */
    attachListeneners: function() {
        this.getContainer().on(this.listeners);
    },

<span id='Ext-scroll-Scroller-method-detachListeners'>    /**
</span>     * @private
     */
    detachListeners: function() {
        this.getContainer().un(this.listeners);
    },

<span id='Ext-scroll-Scroller-method-updateDisabled'>    /**
</span>     * @private
     */
    updateDisabled: function(disabled) {
        if (disabled) {
            this.detachListeners();
        }
        else {
            this.attachListeneners();
        }
    },

<span id='Ext-scroll-Scroller-method-updateInitialOffset'>    updateInitialOffset: function(initialOffset) {
</span>        if (typeof initialOffset == &#39;number&#39;) {
            initialOffset = {
                x: initialOffset,
                y: initialOffset
            };
        }

        var position = this.position,
            x, y;

        position.x = x = initialOffset.x;
        position.y = y = initialOffset.y;

        this.getTranslatable().translate(-x, -y);
    },

<span id='Ext-scroll-Scroller-method-applyDirection'>    /**
</span>     * @private
     * @return {String}
     */
    applyDirection: function(direction) {
        var minPosition = this.getMinPosition(),
            maxPosition = this.getMaxPosition(),
            isHorizontal, isVertical;

        this.givenDirection = direction;

        if (direction === &#39;auto&#39;) {
            isHorizontal = maxPosition.x &gt; minPosition.x;
            isVertical = maxPosition.y &gt; minPosition.y;

            if (isHorizontal &amp;&amp; isVertical) {
                direction = &#39;both&#39;;
            }
            else if (isHorizontal) {
                direction = &#39;horizontal&#39;;
            }
            else {
                direction = &#39;vertical&#39;;
            }
        }

        return direction;
    },

<span id='Ext-scroll-Scroller-method-updateDirection'>    /**
</span>     * @private
     */
    updateDirection: function(direction, oldDirection) {
        var isAxisEnabledFlags = this.isAxisEnabledFlags,
            verticalCls = this.cls + &#39;-vertical&#39;,
            horizontalCls = this.cls + &#39;-horizontal&#39;,
            element = this.getElement();

        if (oldDirection === &#39;both&#39; || oldDirection === &#39;horizontal&#39;) {
            element.removeCls(horizontalCls);
        }

        if (oldDirection === &#39;both&#39; || oldDirection === &#39;vertical&#39;) {
            element.removeCls(verticalCls);
        }

        isAxisEnabledFlags.x = isAxisEnabledFlags.y = false;
        if (direction === &#39;both&#39; || direction === &#39;horizontal&#39;) {
            isAxisEnabledFlags.x = true;
            element.addCls(horizontalCls);
        }

        if (direction === &#39;both&#39; || direction === &#39;vertical&#39;) {
            isAxisEnabledFlags.y = true;
            element.addCls(verticalCls);
        }
    },

<span id='Ext-scroll-Scroller-method-isAxisEnabled'>    /**
</span>     * Returns `true` if a specified axis is enabled.
     * @param {String} axis The axis to check (`x` or `y`).
     * @return {Boolean} `true` if the axis is enabled.
     */
    isAxisEnabled: function(axis) {
        this.getDirection();

        return this.isAxisEnabledFlags[axis];
    },

<span id='Ext-scroll-Scroller-method-applyMomentumEasing'>    /**
</span>     * @private
     * @return {Object}
     */
    applyMomentumEasing: function(easing) {
        var defaultClass = Ext.fx.easing.BoundMomentum;

        return {
            x: Ext.factory(easing, defaultClass),
            y: Ext.factory(easing, defaultClass)
        };
    },

<span id='Ext-scroll-Scroller-method-applyBounceEasing'>    /**
</span>     * @private
     * @return {Object}
     */
    applyBounceEasing: function(easing) {
        var defaultClass = Ext.fx.easing.EaseOut;

        return {
            x: Ext.factory(easing, defaultClass),
            y: Ext.factory(easing, defaultClass)
        };
    },

<span id='Ext-scroll-Scroller-method-updateBounceEasing'>    updateBounceEasing: function(easing) {
</span>        this.getTranslatable().setEasingX(easing.x).setEasingY(easing.y);
    },

<span id='Ext-scroll-Scroller-method-applySlotSnapEasing'>    /**
</span>     * @private
     * @return {Object}
     */
    applySlotSnapEasing: function(easing) {
        var defaultClass = Ext.fx.easing.EaseOut;

        return {
            x: Ext.factory(easing, defaultClass),
            y: Ext.factory(easing, defaultClass)
        };
    },

<span id='Ext-scroll-Scroller-method-getMinPosition'>    /**
</span>     * @private
     * @return {Object}
     */
    getMinPosition: function() {
        var minPosition = this.minPosition;

        if (!minPosition) {
            this.minPosition = minPosition = {
                x: 0,
                y: 0
            };

            this.fireEvent(&#39;minpositionchange&#39;, this, minPosition);
        }

        return minPosition;
    },

<span id='Ext-scroll-Scroller-method-getMaxPosition'>    /**
</span>     * @private
     * @return {Object}
     */
    getMaxPosition: function() {
        var maxPosition = this.maxPosition,
            size, containerSize;

        if (!maxPosition) {
            size = this.getSize();
            containerSize = this.getContainerSize();

            this.maxPosition = maxPosition = {
                x: Math.max(0, size.x - containerSize.x),
                y: Math.max(0, size.y - containerSize.y)
            };

            this.fireEvent(&#39;maxpositionchange&#39;, this, maxPosition);
        }

        return maxPosition;
    },

<span id='Ext-scroll-Scroller-method-refreshMaxPosition'>    /**
</span>     * @private
     */
    refreshMaxPosition: function() {
        this.maxPosition = null;
        this.getMaxPosition();
    },

<span id='Ext-scroll-Scroller-method-applyContainerSize'>    /**
</span>     * @private
     * @return {Object}
     */
    applyContainerSize: function(size) {
        var containerDom = this.getContainer().dom,
            x, y;

        if (!containerDom) {
            return;
        }

        this.givenContainerSize = size;

        if (size === &#39;auto&#39;) {
            x = containerDom.offsetWidth;
            y = containerDom.offsetHeight;
        }
        else {
            x = size.x;
            y = size.y;
        }

        return {
            x: x,
            y: y
        };
    },

<span id='Ext-scroll-Scroller-method-applySize'>    /**
</span>     * @private
     * @param {String/Object} size
     * @return {Object}
     */
    applySize: function(size) {
        var dom = this.getElement().dom,
            x, y;

        if (!dom) {
            return;
        }

        this.givenSize = size;

        if (size === &#39;auto&#39;) {
            x = dom.offsetWidth;
            y = dom.offsetHeight;
        }
        else if (typeof size == &#39;number&#39;) {
            x = size;
            y = size;
        }
        else {
            x = size.x;
            y = size.y;
        }

        return {
            x: x,
            y: y
        };
    },

<span id='Ext-scroll-Scroller-method-updateAutoRefresh'>    /**
</span>     * @private
     */
    updateAutoRefresh: function(autoRefresh) {
        this.getElement().toggleListener(autoRefresh, &#39;resize&#39;, &#39;onElementResize&#39;, this);
        this.getContainer().toggleListener(autoRefresh, &#39;resize&#39;, &#39;onContainerResize&#39;, this);
    },

<span id='Ext-scroll-Scroller-method-applySlotSnapSize'>    applySlotSnapSize: function(snapSize) {
</span>        if (typeof snapSize == &#39;number&#39;) {
            return {
                x: snapSize,
                y: snapSize
            };
        }

        return snapSize;
    },

<span id='Ext-scroll-Scroller-method-applySlotSnapOffset'>    applySlotSnapOffset: function(snapOffset) {
</span>        if (typeof snapOffset == &#39;number&#39;) {
            return {
                x: snapOffset,
                y: snapOffset
            };
        }

        return snapOffset;
    },

<span id='Ext-scroll-Scroller-method-getContainer'>    /**
</span>     * @private
     * Returns the container for this scroller
     */
    getContainer: function() {
        var container = this.container,
            element;

        if (!container) {
            element = this.getElement().getParent();
            this.container = container = this.FixedHBoxStretching ? element.getParent() : element;
            //&lt;debug error&gt;
            if (!container) {
                Ext.Logger.error(&quot;Making an element scrollable that doesn&#39;t have any container&quot;);
            }
            //&lt;/debug&gt;
            container.addCls(this.containerCls);
        }

        return container;
    },

<span id='Ext-scroll-Scroller-method-refresh'>    /**
</span>     * @private
     * @return {Ext.scroll.Scroller} this
     * @chainable
     */
    refresh: function() {
        this.stopAnimation();

        this.getTranslatable().refresh();
        this.setSize(this.givenSize);
        this.setContainerSize(this.givenContainerSize);
        this.setDirection(this.givenDirection);

        this.fireEvent(&#39;refresh&#39;, this);

        return this;
    },

<span id='Ext-scroll-Scroller-method-onElementResize'>    onElementResize: function(element, info) {
</span>        this.setSize({
            x: info.width,
            y: info.height
        });

        this.refresh();
    },

<span id='Ext-scroll-Scroller-method-onContainerResize'>    onContainerResize: function(container, info) {
</span>        this.setContainerSize({
            x: info.width,
            y: info.height
        });

        this.refresh();
    },

<span id='Ext-scroll-Scroller-method-scrollTo'>    /**
</span>     * Scrolls to the given location.
     *
     * @param {Number} x The scroll position on the x axis.
     * @param {Number} y The scroll position on the y axis.
     * @param {Boolean/Object} animation (optional) Whether or not to animate the scrolling to the new position.
     *
     * @return {Ext.scroll.Scroller} this
     * @chainable
     */
    scrollTo: function(x, y, animation) {
        if (this.isDestroyed) {
            return this;
        }

        //&lt;deprecated product=touch since=2.0&gt;
        if (typeof x != &#39;number&#39; &amp;&amp; arguments.length === 1) {
            //&lt;debug warn&gt;
            Ext.Logger.deprecate(&quot;Calling scrollTo() with an object argument is deprecated, &quot; +
                &quot;please pass x and y arguments instead&quot;, this);
            //&lt;/debug&gt;

            y = x.y;
            x = x.x;
        }
        //&lt;/deprecated&gt;

        var translatable = this.getTranslatable(),
            position = this.position,
            positionChanged = false,
            translationX, translationY;

        if (this.isAxisEnabled(&#39;x&#39;)) {
            if (isNaN(x) || typeof x != &#39;number&#39;) {
                x = position.x;
            }
            else {
                if (position.x !== x) {
                    position.x = x;
                    positionChanged = true;
                }
            }

            translationX = -x;
        }

        if (this.isAxisEnabled(&#39;y&#39;)) {
            if (isNaN(y) || typeof y != &#39;number&#39;) {
                y = position.y;
            }
            else {
                if (position.y !== y) {
                    position.y = y;
                    positionChanged = true;
                }
            }

            translationY = -y;
        }

        if (positionChanged) {
            if (animation !== undefined &amp;&amp; animation !== false) {
                translatable.translateAnimated(translationX, translationY, animation);
            }
            else {
                this.fireEvent(&#39;scroll&#39;, this, position.x, position.y);
                translatable.translate(translationX, translationY);
            }
        }

        return this;
    },

<span id='Ext-scroll-Scroller-method-scrollToTop'>    /**
</span>     * @private
     * @return {Ext.scroll.Scroller} this
     * @chainable
     */
    scrollToTop: function(animation) {
        var initialOffset = this.getInitialOffset();

        return this.scrollTo(initialOffset.x, initialOffset.y, animation);
    },

<span id='Ext-scroll-Scroller-method-scrollToEnd'>    /**
</span>     * Scrolls to the end of the scrollable view.
     * @return {Ext.scroll.Scroller} this
     * @chainable
     */
    scrollToEnd: function(animation) {
        var size    = this.getSize(),
            cntSize = this.getContainerSize();

        return this.scrollTo(size.x - cntSize.x, size.y - cntSize.y, animation);
    },

<span id='Ext-scroll-Scroller-method-scrollBy'>    /**
</span>     * Change the scroll offset by the given amount.
     * @param {Number} x The offset to scroll by on the x axis.
     * @param {Number} y The offset to scroll by on the y axis.
     * @param {Boolean/Object} animation (optional) Whether or not to animate the scrolling to the new position.
     * @return {Ext.scroll.Scroller} this
     * @chainable
     */
    scrollBy: function(x, y, animation) {
        var position = this.position;

        x = (typeof x == &#39;number&#39;) ? x + position.x : null;
        y = (typeof y == &#39;number&#39;) ? y + position.y : null;

        return this.scrollTo(x, y, animation);
    },

<span id='Ext-scroll-Scroller-method-onTouchStart'>    /**
</span>     * @private
     */
    onTouchStart: function() {
        this.isTouching = true;
        this.stopAnimation();
    },

<span id='Ext-scroll-Scroller-method-onTouchEnd'>    /**
</span>     * @private
     */
    onTouchEnd: function() {
        var position = this.position;

        this.isTouching = false;

        if (!this.isDragging &amp;&amp; this.snapToSlot()) {
            this.fireEvent(&#39;scrollstart&#39;, this, position.x, position.y);
        }
    },

<span id='Ext-scroll-Scroller-method-onDragStart'>    /**
</span>     * @private
     */
    onDragStart: function(e) {
        var direction = this.getDirection(),
            absDeltaX = e.absDeltaX,
            absDeltaY = e.absDeltaY,
            directionLock = this.getDirectionLock(),
            startPosition = this.startPosition,
            flickStartPosition = this.flickStartPosition,
            flickStartTime = this.flickStartTime,
            lastDragPosition = this.lastDragPosition,
            currentPosition = this.position,
            dragDirection = this.dragDirection,
            x = currentPosition.x,
            y = currentPosition.y,
            now = Ext.Date.now();

        this.isDragging = true;

        if (directionLock &amp;&amp; direction !== &#39;both&#39;) {
            if ((direction === &#39;horizontal&#39; &amp;&amp; absDeltaX &gt; absDeltaY)
                    || (direction === &#39;vertical&#39; &amp;&amp; absDeltaY &gt; absDeltaX)) {
                e.stopPropagation();
            }
            else {
                this.isDragging = false;
                return;
            }
        }

        lastDragPosition.x = x;
        lastDragPosition.y = y;

        flickStartPosition.x = x;
        flickStartPosition.y = y;

        startPosition.x = x;
        startPosition.y = y;

        flickStartTime.x = now;
        flickStartTime.y = now;

        dragDirection.x = 0;
        dragDirection.y = 0;

        this.dragStartTime = now;

        this.isDragging = true;

        this.fireEvent(&#39;scrollstart&#39;, this, x, y);
    },

<span id='Ext-scroll-Scroller-method-onAxisDrag'>    /**
</span>     * @private
     */
    onAxisDrag: function(axis, delta) {
        if (!this.isAxisEnabled(axis)) {
            return;
        }

        var flickStartPosition = this.flickStartPosition,
            flickStartTime = this.flickStartTime,
            lastDragPosition = this.lastDragPosition,
            dragDirection = this.dragDirection,
            old = this.position[axis],
            min = this.getMinPosition()[axis],
            max = this.getMaxPosition()[axis],
            start = this.startPosition[axis],
            last = lastDragPosition[axis],
            current = start - delta,
            lastDirection = dragDirection[axis],
            restrictFactor = this.getOutOfBoundRestrictFactor(),
            startMomentumResetTime = this.getStartMomentumResetTime(),
            now = Ext.Date.now(),
            distance;

        if (current &lt; min) {
            current *= restrictFactor;
        }
        else if (current &gt; max) {
            distance = current - max;
            current = max + distance * restrictFactor;
        }

        if (current &gt; last) {
            dragDirection[axis] = 1;
        }
        else if (current &lt; last) {
            dragDirection[axis] = -1;
        }

        if ((lastDirection !== 0 &amp;&amp; (dragDirection[axis] !== lastDirection))
                || (now - flickStartTime[axis]) &gt; startMomentumResetTime) {
            flickStartPosition[axis] = old;
            flickStartTime[axis] = now;
        }

        lastDragPosition[axis] = current;
    },

<span id='Ext-scroll-Scroller-method-onDrag'>    /**
</span>     * @private
     */
    onDrag: function(e) {
        if (!this.isDragging) {
            return;
        }

        var lastDragPosition = this.lastDragPosition;

        this.onAxisDrag(&#39;x&#39;, e.deltaX);
        this.onAxisDrag(&#39;y&#39;, e.deltaY);

        this.scrollTo(lastDragPosition.x, lastDragPosition.y);
    },

<span id='Ext-scroll-Scroller-method-onDragEnd'>    /**
</span>     * @private
     */
    onDragEnd: function(e) {
        var easingX, easingY;

        if (!this.isDragging) {
            return;
        }

        this.dragEndTime = Ext.Date.now();

        this.onDrag(e);

        this.isDragging = false;

        easingX = this.getAnimationEasing(&#39;x&#39;, e);
        easingY = this.getAnimationEasing(&#39;y&#39;, e);

        if (easingX || easingY) {
            this.getTranslatable().animate(easingX, easingY);
        }
        else {
            this.onScrollEnd();
        }
    },

<span id='Ext-scroll-Scroller-method-getAnimationEasing'>    /**
</span>     * @private
     */
    getAnimationEasing: function(axis, e) {
        if (!this.isAxisEnabled(axis)) {
            return null;
        }

        var currentPosition = this.position[axis],
            minPosition = this.getMinPosition()[axis],
            maxPosition = this.getMaxPosition()[axis],
            maxAbsVelocity = this.getMaxAbsoluteVelocity(),
            boundValue = null,
            dragEndTime = this.dragEndTime,
            velocity = e.flick.velocity[axis],
            easing;

        if (currentPosition &lt; minPosition) {
            boundValue = minPosition;
        }
        else if (currentPosition &gt; maxPosition) {
            boundValue = maxPosition;
        }

        // Out of bound, to be pulled back
        if (boundValue !== null) {
            easing = this.getBounceEasing()[axis];
            easing.setConfig({
                startTime: dragEndTime,
                startValue: -currentPosition,
                endValue: -boundValue
            });

            return easing;
        }

        if (velocity === 0) {
            return null;
        }

        if (velocity &lt; -maxAbsVelocity) {
            velocity = -maxAbsVelocity;
        }
        else if (velocity &gt; maxAbsVelocity) {
            velocity = maxAbsVelocity;
        }

        if (Ext.browser.is.IE) {
            velocity *= 2;
        }

        easing = this.getMomentumEasing()[axis];
        easing.setConfig({
            startTime: dragEndTime,
            startValue: -currentPosition,
            startVelocity: velocity * 1.5,
            minMomentumValue: -maxPosition,
            maxMomentumValue: 0
        });

        return easing;
    },

<span id='Ext-scroll-Scroller-method-onAnimationFrame'>    /**
</span>     * @private
     */
    onAnimationFrame: function(translatable, x, y) {
        var position = this.position;

        position.x = -x;
        position.y = -y;

        this.fireEvent(&#39;scroll&#39;, this, position.x, position.y);
    },

<span id='Ext-scroll-Scroller-method-onAnimationEnd'>    /**
</span>     * @private
     */
    onAnimationEnd: function() {
        this.snapToBoundary();
        this.onScrollEnd();
    },

<span id='Ext-scroll-Scroller-method-stopAnimation'>    /**
</span>     * @private
     * Stops the animation of the scroller at any time.
     */
    stopAnimation: function() {
        this.getTranslatable().stopAnimation();
    },

<span id='Ext-scroll-Scroller-method-onScrollEnd'>    /**
</span>     * @private
     */
    onScrollEnd: function() {
        var position = this.position;

        if (this.isTouching || !this.snapToSlot()) {
            this.fireEvent(&#39;scrollend&#39;, this, position.x, position.y);
        }
    },

<span id='Ext-scroll-Scroller-method-snapToSlot'>    /**
</span>     * @private
     * @return {Boolean}
     */
    snapToSlot: function() {
        var snapX = this.getSnapPosition(&#39;x&#39;),
            snapY = this.getSnapPosition(&#39;y&#39;),
            easing = this.getSlotSnapEasing();

        if (snapX !== null || snapY !== null) {
            this.scrollTo(snapX, snapY, {
                easingX: easing.x,
                easingY: easing.y
            });

            return true;
        }

        return false;
    },

<span id='Ext-scroll-Scroller-method-getSnapPosition'>    /**
</span>     * @private
     * @return {Number/null}
     */
    getSnapPosition: function(axis) {
        var snapSize = this.getSlotSnapSize()[axis],
            snapPosition = null,
            position, snapOffset, maxPosition, mod;

        if (snapSize !== 0 &amp;&amp; this.isAxisEnabled(axis)) {
            position = this.position[axis];
            snapOffset = this.getSlotSnapOffset()[axis];
            maxPosition = this.getMaxPosition()[axis];

            mod = Math.floor((position - snapOffset) % snapSize);

            if (mod !== 0) {
                if (position !== maxPosition) {
                    if (Math.abs(mod) &gt; snapSize / 2) {
                        snapPosition = Math.min(maxPosition, position + ((mod &gt; 0) ? snapSize - mod : mod - snapSize));
                    }
                    else {
                        snapPosition = position - mod;
                    }
                }
                else {
                    snapPosition = position - mod;
                }
            }
        }

        return snapPosition;
    },

<span id='Ext-scroll-Scroller-method-snapToBoundary'>    /**
</span>     * @private
     */
    snapToBoundary: function() {
        var position = this.position,
            minPosition = this.getMinPosition(),
            maxPosition = this.getMaxPosition(),
            minX = minPosition.x,
            minY = minPosition.y,
            maxX = maxPosition.x,
            maxY = maxPosition.y,
            x = Math.round(position.x),
            y = Math.round(position.y);

        if (x &lt; minX) {
            x = minX;
        }
        else if (x &gt; maxX) {
            x = maxX;
        }

        if (y &lt; minY) {
            y = minY;
        }
        else if (y &gt; maxY) {
            y = maxY;
        }

        this.scrollTo(x, y);
    },

<span id='Ext-scroll-Scroller-method-destroy'>    destroy: function() {
</span>        var element = this.getElement(),
            sizeMonitors = this.sizeMonitors,
            container;

        if (sizeMonitors) {
            sizeMonitors.element.destroy();
            sizeMonitors.container.destroy();
        }

        if (element &amp;&amp; !element.isDestroyed) {
            element.removeCls(this.cls);
            container = this.getContainer();
            if (container &amp;&amp; !container.isDestroyed) {
                container.removeCls(this.containerCls);
            }
        }

        Ext.destroy(this.getTranslatable());

        this.callParent(arguments);
    }

}, function() {
    //&lt;deprecated product=touch since=2.0&gt;
    this.override({
        constructor: function(config) {
            var element, acceleration, slotSnapOffset, friction, springTension, minVelocity;

            if (!config) {
                config = {};
            }

            if (typeof config == &#39;string&#39;) {
                config = {
                    direction: config
                };
            }

            if (arguments.length == 2) {
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;Passing element as the first argument is deprecated, pass it as the &quot; +
                    &quot;&#39;element&#39; property of the config object instead&quot;);
                //&lt;/debug&gt;
                element = config;
                config = arguments[1];

                if (!config) {
                    config = {};
                }

                config.element = element;
            }

<span id='Ext-scroll-Scroller-cfg-acceleration'>            /**
</span>             * @cfg {Number} acceleration A higher acceleration gives the scroller more initial velocity.
             * @deprecated 2.0.0 Please use {@link #momentumEasing}.momentum.acceleration and {@link #momentumEasing}.bounce.acceleration instead.
             */
            if (config.hasOwnProperty(&#39;acceleration&#39;)) {
                acceleration = config.acceleration;
                delete config.acceleration;
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;&#39;acceleration&#39; config is deprecated, set momentumEasing.momentum.acceleration and momentumEasing.bounce.acceleration configs instead&quot;);
                //&lt;/debug&gt;

                Ext.merge(config, {
                    momentumEasing: {
                        momentum: { acceleration: acceleration },
                        bounce: { acceleration: acceleration }
                    }
                });
            }

            if (config.hasOwnProperty(&#39;snap&#39;)) {
                config.slotSnapOffset = config.snap;
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;&#39;snap&#39; config is deprecated, please use the &#39;slotSnapOffset&#39; config instead&quot;);
                //&lt;/debug&gt;
            }

<span id='Ext-scroll-Scroller-cfg-friction'>            /**
</span>             * @cfg {Number} friction The friction of the scroller. By raising this value the length that momentum scrolls
             * becomes shorter. This value is best kept between 0 and 1.
             * @deprecated 2.0.0 Please set the {@link #momentumEasing}.momentum.friction configuration instead
             */
            if (config.hasOwnProperty(&#39;friction&#39;)) {
                friction = config.friction;
                delete config.friction;
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;&#39;friction&#39; config is deprecated, set momentumEasing.momentum.friction config instead&quot;);
                //&lt;/debug&gt;

                Ext.merge(config, {
                    momentumEasing: {
                        momentum: { friction: friction }
                    }
                });
            }

            if (config.hasOwnProperty(&#39;springTension&#39;)) {
                springTension = config.springTension;
                delete config.springTension;
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;&#39;springTension&#39; config is deprecated, set momentumEasing.momentum.springTension config instead&quot;);
                //&lt;/debug&gt;

                Ext.merge(config, {
                    momentumEasing: {
                        momentum: { springTension: springTension }
                    }
                });
            }

            if (config.hasOwnProperty(&#39;minVelocityForAnimation&#39;)) {
                minVelocity = config.minVelocityForAnimation;
                delete config.minVelocityForAnimation;
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;&#39;minVelocityForAnimation&#39; config is deprecated, set momentumEasing.minVelocity config instead&quot;);
                //&lt;/debug&gt;

                Ext.merge(config, {
                    momentumEasing: {
                        minVelocity: minVelocity
                    }
                });
            }

            this.callOverridden(arguments);
        },

        scrollToAnimated: function(x, y, animation) {
            //&lt;debug warn&gt;
            Ext.Logger.deprecate(&quot;scrollToAnimated() is deprecated, please use `scrollTo()` and pass &#39;animation&#39; as &quot; +
                &quot;the third argument instead&quot;);
            //&lt;/debug&gt;

            return this.scrollTo.apply(this, arguments);
        },

        scrollBy: function(x, y, animation) {
            if (Ext.isObject(x)) {
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;calling `scrollBy()` with an object of `x` and `y` properties is no longer supported. &quot; +
                        &quot;Please pass `x` and `y` values as two separate arguments instead&quot;);
                //&lt;/debug&gt;
                y = x.y;
                x = x.x;
            }

            return this.callOverridden([x, y, animation]);
        },

<span id='Ext-scroll-Scroller-method-setOffset'>        /**
</span>         * Sets the offset of this scroller.
         * @param {Object} offset The offset to move to.
         * @param {Number} offset.x The x-axis offset.
         * @param {Number} offset.y The y-axis offset.
         * @deprecated 2.0.0 Please use `{@link #scrollTo}` instead.
         * @return {Ext.scroll.Scroller} this
         * @chainable
         */
        setOffset: function(offset) {
            return this.scrollToAnimated(-offset.x, -offset.y);
        }
    });

<span id='Ext-scroll-Scroller-method-updateBoundary'>    /**
</span>     * @method updateBoundary
     * Updates the boundary information for this scroller.
     * @return {Ext.scroll.Scroller} this
     * @removed 2.0.0 Please use {@link #method-refresh} instead.
     * @chainable
     */
//    Ext.deprecateClassMethod(&#39;updateBoundary&#39;, &#39;refresh&#39;);
    //&lt;/deprecated&gt;
});
</pre>
</body>
</html>
