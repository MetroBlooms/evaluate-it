<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">//@tag foundation,core
//@define Ext.Base
//@require Ext.Date

<span id='Ext-Base'>/**
</span> * @class Ext.Base
 *
 * @author Jacky Nguyen &lt;jacky@sencha.com&gt;
 * @aside guide class_system
 * @aside video class-system
 *
 * The root of all classes created with {@link Ext#define}.
 *
 * Ext.Base is the building block of all Ext classes. All classes in Ext inherit from Ext.Base. All prototype and static
 * members of this class are inherited by all other classes.
 *
 * See the [Class System Guide](#!/guide/class_system) for more.
 *
 */
(function(flexSetter) {

var noArgs = [],
    Base = function(){};

    // These static properties will be copied to every newly created class with {@link Ext#define}
    Ext.apply(Base, {
        $className: &#39;Ext.Base&#39;,

        $isClass: true,

<span id='Ext-Base-static-method-create'>        /**
</span>         * Create a new instance of this Class.
         *
         *     Ext.define(&#39;My.cool.Class&#39;, {
         *         // ...
         *     });
         *
         *     My.cool.Class.create({
         *         someConfig: true
         *     });
         *
         * All parameters are passed to the constructor of the class.
         *
         * @return {Object} the created instance.
         * @static
         * @inheritable
         */
        create: function() {
            return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
        },

<span id='Ext-Base-static-method-extend'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        extend: function(parent) {
            var parentPrototype = parent.prototype,
                prototype, i, ln, name, statics;

            prototype = this.prototype = Ext.Object.chain(parentPrototype);
            prototype.self = this;

            this.superclass = prototype.superclass = parentPrototype;

            if (!parent.$isClass) {
                Ext.apply(prototype, Ext.Base.prototype);
                prototype.constructor = function() {
                    parentPrototype.constructor.apply(this, arguments);
                };
            }

            //&lt;feature classSystem.inheritableStatics&gt;
            // Statics inheritance
            statics = parentPrototype.$inheritableStatics;

            if (statics) {
                for (i = 0,ln = statics.length; i &lt; ln; i++) {
                    name = statics[i];

                    if (!this.hasOwnProperty(name)) {
                        this[name] = parent[name];
                    }
                }
            }
            //&lt;/feature&gt;

            if (parent.$onExtended) {
                this.$onExtended = parent.$onExtended.slice();
            }

            //&lt;feature classSystem.config&gt;
            prototype.config = prototype.defaultConfig = new prototype.configClass;
            prototype.initConfigList = prototype.initConfigList.slice();
            prototype.initConfigMap = Ext.Object.chain(prototype.initConfigMap);
            //&lt;/feature&gt;
        },

<span id='Ext-Base-static-property-S-onExtended'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        &#39;$onExtended&#39;: [],

<span id='Ext-Base-static-method-triggerExtended'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        triggerExtended: function() {
            var callbacks = this.$onExtended,
                ln = callbacks.length,
                i, callback;

            if (ln &gt; 0) {
                for (i = 0; i &lt; ln; i++) {
                    callback = callbacks[i];
                    callback.fn.apply(callback.scope || this, arguments);
                }
            }
        },

<span id='Ext-Base-static-method-onExtended'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        onExtended: function(fn, scope) {
            this.$onExtended.push({
                fn: fn,
                scope: scope
            });

            return this;
        },

<span id='Ext-Base-static-method-addConfig'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        addConfig: function(config, fullMerge) {
            var prototype = this.prototype,
                initConfigList = prototype.initConfigList,
                initConfigMap = prototype.initConfigMap,
                defaultConfig = prototype.defaultConfig,
                hasInitConfigItem, name, value;

            fullMerge = Boolean(fullMerge);

            for (name in config) {
                if (config.hasOwnProperty(name) &amp;&amp; (fullMerge || !(name in defaultConfig))) {
                    value = config[name];
                    hasInitConfigItem = initConfigMap[name];

                    if (value !== null) {
                        if (!hasInitConfigItem) {
                            initConfigMap[name] = true;
                            initConfigList.push(name);
                        }
                    }
                    else if (hasInitConfigItem) {
                        initConfigMap[name] = false;
                        Ext.Array.remove(initConfigList, name);
                    }
                }
            }

            if (fullMerge) {
                Ext.merge(defaultConfig, config);
            }
            else {
                Ext.mergeIf(defaultConfig, config);
            }

            prototype.configClass = Ext.Object.classify(defaultConfig);
        },

<span id='Ext-Base-static-method-addStatics'>        /**
</span>         * Add / override static properties of this class.
         *
         *     Ext.define(&#39;My.cool.Class&#39;, {
         *         // this.se
         *     });
         *
         *     My.cool.Class.addStatics({
         *         someProperty: &#39;someValue&#39;,      // My.cool.Class.someProperty = &#39;someValue&#39;
         *         method1: function() {  },    // My.cool.Class.method1 = function() { ... };
         *         method2: function() {  }     // My.cool.Class.method2 = function() { ... };
         *     });
         *
         * @param {Object} members
         * @return {Ext.Base} this
         * @static
         * @inheritable
         */
        addStatics: function(members) {
            var member, name;
            //&lt;debug&gt;
            var className = Ext.getClassName(this);
            //&lt;/debug&gt;

            for (name in members) {
                if (members.hasOwnProperty(name)) {
                    member = members[name];
                    //&lt;debug&gt;
                    if (typeof member == &#39;function&#39;) {
                        member.displayName = className + &#39;.&#39; + name;
                    }
                    //&lt;/debug&gt;
                    this[name] = member;
                }
            }

            return this;
        },

<span id='Ext-Base-static-method-addInheritableStatics'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        addInheritableStatics: function(members) {
            var inheritableStatics,
                hasInheritableStatics,
                prototype = this.prototype,
                name, member;

            inheritableStatics = prototype.$inheritableStatics;
            hasInheritableStatics = prototype.$hasInheritableStatics;

            if (!inheritableStatics) {
                inheritableStatics = prototype.$inheritableStatics = [];
                hasInheritableStatics = prototype.$hasInheritableStatics = {};
            }

            //&lt;debug&gt;
            var className = Ext.getClassName(this);
            //&lt;/debug&gt;

            for (name in members) {
                if (members.hasOwnProperty(name)) {
                    member = members[name];
                    //&lt;debug&gt;
                    if (typeof member == &#39;function&#39;) {
                        member.displayName = className + &#39;.&#39; + name;
                    }
                    //&lt;/debug&gt;
                    this[name] = member;

                    if (!hasInheritableStatics[name]) {
                        hasInheritableStatics[name] = true;
                        inheritableStatics.push(name);
                    }
                }
            }

            return this;
        },

<span id='Ext-Base-static-method-addMembers'>        /**
</span>         * Add methods / properties to the prototype of this class.
         *
         *     @example
         *     Ext.define(&#39;My.awesome.Cat&#39;, {
         *         constructor: function() {
         *             // ...
         *         }
         *     });
         *
         *      My.awesome.Cat.addMembers({
         *          meow: function() {
         *             alert(&#39;Meowww...&#39;);
         *          }
         *      });
         *
         *      var kitty = new My.awesome.Cat();
         *      kitty.meow();
         *
         * @param {Object} members
         * @static
         * @inheritable
         */
        addMembers: function(members) {
            var prototype = this.prototype,
                names = [],
                name, member;

            //&lt;debug&gt;
            var className = this.$className || &#39;&#39;;
            //&lt;/debug&gt;

            for (name in members) {
                if (members.hasOwnProperty(name)) {
                    member = members[name];

                    if (typeof member == &#39;function&#39; &amp;&amp; !member.$isClass &amp;&amp; member !== Ext.emptyFn) {
                        member.$owner = this;
                        member.$name = name;
                        //&lt;debug&gt;
                        member.displayName = className + &#39;#&#39; + name;
                        //&lt;/debug&gt;
                    }

                    prototype[name] = member;
                }
            }

            return this;
        },

<span id='Ext-Base-static-method-addMember'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        addMember: function(name, member) {
            if (typeof member == &#39;function&#39; &amp;&amp; !member.$isClass &amp;&amp; member !== Ext.emptyFn) {
                member.$owner = this;
                member.$name = name;
                //&lt;debug&gt;
                member.displayName = (this.$className || &#39;&#39;) + &#39;#&#39; + name;
                //&lt;/debug&gt;
            }

            this.prototype[name] = member;

            return this;
        },

<span id='Ext-Base-static-method-implement'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        implement: function() {
            this.addMembers.apply(this, arguments);
        },

<span id='Ext-Base-static-method-borrow'>        /**
</span>         * Borrow another class&#39; members to the prototype of this class.
         *
         *     Ext.define(&#39;Bank&#39;, {
         *         money: &#39;$$$&#39;,
         *         printMoney: function() {
         *             alert(&#39;$$$$$$$&#39;);
         *         }
         *     });
         *
         *     Ext.define(&#39;Thief&#39;, {
         *         // ...
         *     });
         *
         *     Thief.borrow(Bank, [&#39;money&#39;, &#39;printMoney&#39;]);
         *
         *     var steve = new Thief();
         *
         *     alert(steve.money); // alerts &#39;$$$&#39;
         *     steve.printMoney(); // alerts &#39;$$$$$$$&#39;
         *
         * @param {Ext.Base} fromClass The class to borrow members from
         * @param {Array/String} members The names of the members to borrow
         * @return {Ext.Base} this
         * @static
         * @inheritable
         * @private
         */
        borrow: function(fromClass, members) {
            var prototype = this.prototype,
                fromPrototype = fromClass.prototype,
                //&lt;debug&gt;
                className = Ext.getClassName(this),
                //&lt;/debug&gt;
                i, ln, name, fn, toBorrow;

            members = Ext.Array.from(members);

            for (i = 0,ln = members.length; i &lt; ln; i++) {
                name = members[i];

                toBorrow = fromPrototype[name];

                if (typeof toBorrow == &#39;function&#39;) {
                    fn = function() {
                        return toBorrow.apply(this, arguments);
                    };

                    //&lt;debug&gt;
                    if (className) {
                        fn.displayName = className + &#39;#&#39; + name;
                    }
                    //&lt;/debug&gt;

                    fn.$owner = this;
                    fn.$name = name;

                    prototype[name] = fn;
                }
                else {
                    prototype[name] = toBorrow;
                }
            }

            return this;
        },

<span id='Ext-Base-static-method-override'>        /**
</span>         * Override members of this class. Overridden methods can be invoked via
         * {@link Ext.Base#callParent}.
         *
         *     Ext.define(&#39;My.Cat&#39;, {
         *         constructor: function() {
         *             alert(&quot;I&#39;m a cat!&quot;);
         *         }
         *     });
         *
         *     My.Cat.override({
         *         constructor: function() {
         *             alert(&quot;I&#39;m going to be a cat!&quot;);
         *
         *             var instance = this.callParent(arguments);
         *
         *             alert(&quot;Meeeeoooowwww&quot;);
         *
         *             return instance;
         *         }
         *     });
         *
         *     var kitty = new My.Cat(); // alerts &quot;I&#39;m going to be a cat!&quot;
         *                               // alerts &quot;I&#39;m a cat!&quot;
         *                               // alerts &quot;Meeeeoooowwww&quot;
         *
         * As of 2.1, direct use of this method is deprecated. Use {@link Ext#define Ext.define}
         * instead:
         *
         *     Ext.define(&#39;My.CatOverride&#39;, {
         *         override: &#39;My.Cat&#39;,
         *
         *         constructor: function() {
         *             alert(&quot;I&#39;m going to be a cat!&quot;);
         *
         *             var instance = this.callParent(arguments);
         *
         *             alert(&quot;Meeeeoooowwww&quot;);
         *
         *             return instance;
         *         }
         *     });
         *
         * The above accomplishes the same result but can be managed by the {@link Ext.Loader}
         * which can properly order the override and its target class and the build process
         * can determine whether the override is needed based on the required state of the
         * target class (My.Cat).
         *
         * @param {Object} members The properties to add to this class. This should be
         * specified as an object literal containing one or more properties.
         * @return {Ext.Base} this class
         * @static
         * @inheritable
         * @deprecated 2.1.0 Please use {@link Ext#define Ext.define} instead
         */
        override: function(members) {
            var me = this,
                enumerables = Ext.enumerables,
                target = me.prototype,
                cloneFunction = Ext.Function.clone,
                currentConfig = target.config,
                name, index, member, statics, names, previous, newConfig, prop;

            if (arguments.length === 2) {
                name = members;
                members = {};
                members[name] = arguments[1];
                enumerables = null;
            }

            do {
                names = []; // clean slate for prototype (1st pass) and static (2nd pass)
                statics = null; // not needed 1st pass, but needs to be cleared for 2nd pass

                for (name in members) { // hasOwnProperty is checked in the next loop...
                    if (name == &#39;statics&#39;) {
                        statics = members[name];
                    }
                    else if (name == &#39;config&#39;) {
                        newConfig = members[name];
                        //&lt;debug error&gt;
                        for (prop in newConfig) {
                            if (!(prop in currentConfig)) {
                                throw new Error(&quot;Attempting to override a non-existant config property. This is not &quot; +
                                    &quot;supported, you must extend the Class.&quot;);
                            }
                        }
                        //&lt;/debug&gt;
                        me.addConfig(newConfig, true);
                    }
                    else {
                        names.push(name);
                    }
                }

                if (enumerables) {
                    names.push.apply(names, enumerables);
                }

                for (index = names.length; index--; ) {
                    name = names[index];

                    if (members.hasOwnProperty(name)) {
                        member = members[name];

                        if (typeof member == &#39;function&#39; &amp;&amp; !member.$className &amp;&amp; member !== Ext.emptyFn) {
                            if (typeof member.$owner != &#39;undefined&#39;) {
                                member = cloneFunction(member);
                            }

                            //&lt;debug&gt;
                            var className = me.$className;
                            if (className) {
                                member.displayName = className + &#39;#&#39; + name;
                            }
                            //&lt;/debug&gt;

                            member.$owner = me;
                            member.$name = name;

                            previous = target[name];
                            if (previous) {
                                member.$previous = previous;
                            }
                        }

                        target[name] = member;
                    }
                }

                target = me; // 2nd pass is for statics
                members = statics; // statics will be null on 2nd pass
            } while (members);

            return this;
        },

<span id='Ext-Base-static-method-callParent'>        /**
</span>         * @protected
         * @static
         * @inheritable
         */
        callParent: function(args) {
            var method;

            // This code is intentionally inlined for the least amount of debugger stepping
            return (method = this.callParent.caller) &amp;&amp; (method.$previous ||
                  ((method = method.$owner ? method : method.caller) &amp;&amp;
                        method.$owner.superclass.$class[method.$name])).apply(this, args || noArgs);
        },

        //&lt;feature classSystem.mixins&gt;
<span id='Ext-Base-static-method-mixin'>        /**
</span>         * Used internally by the mixins pre-processor
         * @private
         * @static
         * @inheritable
         */
        mixin: function(name, mixinClass) {
            var mixin = mixinClass.prototype,
                prototype = this.prototype,
                key;

            if (typeof mixin.onClassMixedIn != &#39;undefined&#39;) {
                mixin.onClassMixedIn.call(mixinClass, this);
            }

            if (!prototype.hasOwnProperty(&#39;mixins&#39;)) {
                if (&#39;mixins&#39; in prototype) {
                    prototype.mixins = Ext.Object.chain(prototype.mixins);
                }
                else {
                    prototype.mixins = {};
                }
            }

            for (key in mixin) {
                if (key === &#39;mixins&#39;) {
                    Ext.merge(prototype.mixins, mixin[key]);
                }
                else if (typeof prototype[key] == &#39;undefined&#39; &amp;&amp; key != &#39;mixinId&#39; &amp;&amp; key != &#39;config&#39;) {
                    prototype[key] = mixin[key];
                }
            }

            //&lt;feature classSystem.config&gt;
            if (&#39;config&#39; in mixin) {
                this.addConfig(mixin.config, false);
            }
            //&lt;/feature&gt;

            prototype.mixins[name] = mixin;
        },
        //&lt;/feature&gt;

<span id='Ext-Base-static-method-getName'>        /**
</span>         * Get the current class&#39; name in string format.
         *
         *     Ext.define(&#39;My.cool.Class&#39;, {
         *         constructor: function() {
         *             alert(this.self.getName()); // alerts &#39;My.cool.Class&#39;
         *         }
         *     });
         *
         *     My.cool.Class.getName(); // &#39;My.cool.Class&#39;
         *
         * @return {String} className
         * @static
         * @inheritable
         */
        getName: function() {
            return Ext.getClassName(this);
        },

<span id='Ext-Base-static-method-createAlias'>        /**
</span>         * Create aliases for existing prototype methods. Example:
         *
         *     Ext.define(&#39;My.cool.Class&#39;, {
         *         method1: function() {  },
         *         method2: function() {  }
         *     });
         *
         *     var test = new My.cool.Class();
         *
         *     My.cool.Class.createAlias({
         *         method3: &#39;method1&#39;,
         *         method4: &#39;method2&#39;
         *     });
         *
         *     test.method3(); // test.method1()
         *
         *     My.cool.Class.createAlias(&#39;method5&#39;, &#39;method3&#39;);
         *
         *     test.method5(); // test.method3() -&gt; test.method1()
         *
         * @param {String/Object} alias The new method name, or an object to set multiple aliases. See
         * {@link Ext.Function#flexSetter flexSetter}
         * @param {String/Object} origin The original method name
         * @static
         * @inheritable
         * @method
         */
        createAlias: flexSetter(function(alias, origin) {
            this.override(alias, function() {
                return this[origin].apply(this, arguments);
            });
        }),

<span id='Ext-Base-static-method-addXtype'>        /**
</span>         * @private
         * @static
         * @inheritable
         */
        addXtype: function(xtype) {
            var prototype = this.prototype,
                xtypesMap = prototype.xtypesMap,
                xtypes = prototype.xtypes,
                xtypesChain = prototype.xtypesChain;

            if (!prototype.hasOwnProperty(&#39;xtypesMap&#39;)) {
                xtypesMap = prototype.xtypesMap = Ext.merge({}, prototype.xtypesMap || {});
                xtypes = prototype.xtypes = prototype.xtypes ? [].concat(prototype.xtypes) : [];
                xtypesChain = prototype.xtypesChain = prototype.xtypesChain ? [].concat(prototype.xtypesChain) : [];
                prototype.xtype = xtype;
            }

            if (!xtypesMap[xtype]) {
                xtypesMap[xtype] = true;
                xtypes.push(xtype);
                xtypesChain.push(xtype);
                Ext.ClassManager.setAlias(this, &#39;widget.&#39; + xtype);
            }

            return this;
        }
    });

    Base.implement({
        isInstance: true,

        $className: &#39;Ext.Base&#39;,

        configClass: Ext.emptyFn,

        initConfigList: [],

        initConfigMap: {},

<span id='Ext-Base-method-statics'>        /**
</span>         * Get the reference to the class from which this object was instantiated. Note that unlike {@link Ext.Base#self},
         * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
         * `this` points to during run-time
         *
         *     Ext.define(&#39;My.Cat&#39;, {
         *         statics: {
         *             totalCreated: 0,
         *             speciesName: &#39;Cat&#39; // My.Cat.speciesName = &#39;Cat&#39;
         *         },
         *
         *         constructor: function() {
         *             var statics = this.statics();
         *
         *             alert(statics.speciesName);     // always equals to &#39;Cat&#39; no matter what &#39;this&#39; refers to
         *                                             // equivalent to: My.Cat.speciesName
         *
         *             alert(this.self.speciesName);   // dependent on &#39;this&#39;
         *
         *             statics.totalCreated++;
         *         },
         *
         *         clone: function() {
         *             var cloned = new this.self();                    // dependent on &#39;this&#39;
         *
         *             cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
         *
         *             return cloned;
         *         }
         *     });
         *
         *
         *     Ext.define(&#39;My.SnowLeopard&#39;, {
         *         extend: &#39;My.Cat&#39;,
         *
         *         statics: {
         *             speciesName: &#39;Snow Leopard&#39;     // My.SnowLeopard.speciesName = &#39;Snow Leopard&#39;
         *         },
         *
         *         constructor: function() {
         *             this.callParent();
         *         }
         *     });
         *
         *     var cat = new My.Cat();                 // alerts &#39;Cat&#39;, then alerts &#39;Cat&#39;
         *
         *     var snowLeopard = new My.SnowLeopard(); // alerts &#39;Cat&#39;, then alerts &#39;Snow Leopard&#39;
         *
         *     var clone = snowLeopard.clone();
         *     alert(Ext.getClassName(clone));         // alerts &#39;My.SnowLeopard&#39;
         *     alert(clone.groupName);                 // alerts &#39;Cat&#39;
         *
         *     alert(My.Cat.totalCreated);             // alerts 3
         *
         * @protected
         * @return {Ext.Class}
         */
        statics: function() {
            var method = this.statics.caller,
                self = this.self;

            if (!method) {
                return self;
            }

            return method.$owner;
        },

<span id='Ext-Base-method-callParent'>        /**
</span>         * Call the &quot;parent&quot; method of the current method. That is the method previously
         * overridden by derivation or by an override (see {@link Ext#define}).
         *
         *      Ext.define(&#39;My.Base&#39;, {
         *          constructor: function (x) {
         *              this.x = x;
         *          },
         *
         *          statics: {
         *              method: function (x) {
         *                  return x;
         *              }
         *          }
         *      });
         *
         *      Ext.define(&#39;My.Derived&#39;, {
         *          extend: &#39;My.Base&#39;,
         *
         *          constructor: function () {
         *              this.callParent([21]);
         *          }
         *      });
         *
         *      var obj = new My.Derived();
         *
         *      alert(obj.x);  // alerts 21
         *
         * This can be used with an override as follows:
         *
         *      Ext.define(&#39;My.DerivedOverride&#39;, {
         *          override: &#39;My.Derived&#39;,
         *
         *          constructor: function (x) {
         *              this.callParent([x*2]); // calls original My.Derived constructor
         *          }
         *      });
         *
         *      var obj = new My.Derived();
         *
         *      alert(obj.x);  // now alerts 42
         *
         * This also works with static methods.
         *
         *      Ext.define(&#39;My.Derived2&#39;, {
         *          extend: &#39;My.Base&#39;,
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x*2]); // calls My.Base.method
         *              }
         *          }
         *      });
         *
         *      alert(My.Base.method(10));     // alerts 10
         *      alert(My.Derived2.method(10)); // alerts 20
         *
         * Lastly, it also works with overridden static methods.
         *
         *      Ext.define(&#39;My.Derived2Override&#39;, {
         *          override: &#39;My.Derived2&#39;,
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x*2]); // calls My.Derived2.method
         *              }
         *          }
         *      });
         *
         *      alert(My.Derived2.method(10)); // now alerts 40
         *
         * To override a method and replace it and also call the superclass method, use
         * {@link #callSuper}. This is often done to patch a method to fix a bug.
         *
         * @protected
         * @param {Array/Arguments} args The arguments, either an array or the `arguments` object
         * from the current method, for example: `this.callParent(arguments)`
         * @return {Object} Returns the result of calling the parent method
         */
        callParent: function(args) {
            // NOTE: this code is deliberately as few expressions (and no function calls)
            // as possible so that a debugger can skip over this noise with the minimum number
            // of steps. Basically, just hit Step Into until you are where you really wanted
            // to be.
            var method,
                superMethod = (method = this.callParent.caller) &amp;&amp; (method.$previous ||
                        ((method = method.$owner ? method : method.caller) &amp;&amp;
                                method.$owner.superclass[method.$name]));

            //&lt;debug error&gt;
            if (!superMethod) {
                method = this.callParent.caller;
                var parentClass, methodName;

                if (!method.$owner) {
                    if (!method.caller) {
                        throw new Error(&quot;Attempting to call a protected method from the public scope, which is not allowed&quot;);
                    }

                    method = method.caller;
                }

                parentClass = method.$owner.superclass;
                methodName = method.$name;

                if (!(methodName in parentClass)) {
                    throw new Error(&quot;this.callParent() was called but there&#39;s no such method (&quot; + methodName +
                                &quot;) found in the parent class (&quot; + (Ext.getClassName(parentClass) || &#39;Object&#39;) + &quot;)&quot;);
                }
            }
            //&lt;/debug&gt;

            return superMethod.apply(this, args || noArgs);
        },

<span id='Ext-Base-method-callSuper'>        /**
</span>         * This method is used by an override to call the superclass method but bypass any
         * overridden method. This is often done to &quot;patch&quot; a method that contains a bug
         * but for whatever reason cannot be fixed directly.
         *
         * Consider:
         *
         *      Ext.define(&#39;Ext.some.Class&#39;, {
         *          method: function () {
         *              console.log(&#39;Good&#39;);
         *          }
         *      });
         *
         *      Ext.define(&#39;Ext.some.DerivedClass&#39;, {
         *          method: function () {
         *              console.log(&#39;Bad&#39;);
         *
         *              // ... logic but with a bug ...
         *
         *              this.callParent();
         *          }
         *      });
         *
         * To patch the bug in `DerivedClass.method`, the typical solution is to create an
         * override:
         *
         *      Ext.define(&#39;App.paches.DerivedClass&#39;, {
         *          override: &#39;Ext.some.DerivedClass&#39;,
         *
         *          method: function () {
         *              console.log(&#39;Fixed&#39;);
         *
         *              // ... logic but with bug fixed ...
         *
         *              this.callSuper();
         *          }
         *      });
         *
         * The patch method cannot use `callParent` to call the superclass `method` since
         * that would call the overridden method containing the bug. In other words, the
         * above patch would only produce &quot;Fixed&quot; then &quot;Good&quot; in the console log, whereas,
         * using `callParent` would produce &quot;Fixed&quot; then &quot;Bad&quot; then &quot;Good&quot;.
         *
         * @protected
         * @param {Array/Arguments} args The arguments, either an array or the `arguments` object
         * from the current method, for example: `this.callSuper(arguments)`
         * @return {Object} Returns the result of calling the superclass method
         */
        callSuper: function(args) {
            var method,
                superMethod = (method = this.callSuper.caller) &amp;&amp; ((method = method.$owner ? method : method.caller) &amp;&amp;
                                method.$owner.superclass[method.$name]);

            //&lt;debug error&gt;
            if (!superMethod) {
                method = this.callSuper.caller;
                var parentClass, methodName;

                if (!method.$owner) {
                    if (!method.caller) {
                        throw new Error(&quot;Attempting to call a protected method from the public scope, which is not allowed&quot;);
                    }

                    method = method.caller;
                }

                parentClass = method.$owner.superclass;
                methodName = method.$name;

                if (!(methodName in parentClass)) {
                    throw new Error(&quot;this.callSuper() was called but there&#39;s no such method (&quot; + methodName +
                                &quot;) found in the parent class (&quot; + (Ext.getClassName(parentClass) || &#39;Object&#39;) + &quot;)&quot;);
                }
            }
            //&lt;/debug&gt;

            return superMethod.apply(this, args || noArgs);
        },

<span id='Ext-Base-method-callOverridden'>        /**
</span>         * Call the original method that was previously overridden with {@link Ext.Base#override},
         *
         * This method is deprecated as {@link #callParent} does the same thing.
         *
         *     Ext.define(&#39;My.Cat&#39;, {
         *         constructor: function() {
         *             alert(&quot;I&#39;m a cat!&quot;);
         *         }
         *     });
         *
         *     My.Cat.override({
         *         constructor: function() {
         *             alert(&quot;I&#39;m going to be a cat!&quot;);
         *
         *             var instance = this.callOverridden();
         *
         *             alert(&quot;Meeeeoooowwww&quot;);
         *
         *             return instance;
         *         }
         *     });
         *
         *     var kitty = new My.Cat(); // alerts &quot;I&#39;m going to be a cat!&quot;
         *                               // alerts &quot;I&#39;m a cat!&quot;
         *                               // alerts &quot;Meeeeoooowwww&quot;
         *
         * @param {Array/Arguments} args The arguments, either an array or the `arguments` object
         * from the current method, for example: `this.callOverridden(arguments)`
         * @return {Object} Returns the result of calling the overridden method
         * @protected
         */
        callOverridden: function(args) {
            var method = this.callOverridden.caller;
            return method  &amp;&amp; method.$previous.apply(this, args || noArgs);
        },

<span id='Ext-Base-property-self'>        /**
</span>         * @property {Ext.Class} self
         *
         * Get the reference to the current class from which this object was instantiated. Unlike {@link Ext.Base#statics},
         * `this.self` is scope-dependent and it&#39;s meant to be used for dynamic inheritance. See {@link Ext.Base#statics}
         * for a detailed comparison
         *
         *     Ext.define(&#39;My.Cat&#39;, {
         *         statics: {
         *             speciesName: &#39;Cat&#39; // My.Cat.speciesName = &#39;Cat&#39;
         *         },
         *
         *         constructor: function() {
         *             alert(this.self.speciesName); // dependent on &#39;this&#39;
         *         },
         *
         *         clone: function() {
         *             return new this.self();
         *         }
         *     });
         *
         *
         *     Ext.define(&#39;My.SnowLeopard&#39;, {
         *         extend: &#39;My.Cat&#39;,
         *         statics: {
         *             speciesName: &#39;Snow Leopard&#39;         // My.SnowLeopard.speciesName = &#39;Snow Leopard&#39;
         *         }
         *     });
         *
         *     var cat = new My.Cat();                     // alerts &#39;Cat&#39;
         *     var snowLeopard = new My.SnowLeopard();     // alerts &#39;Snow Leopard&#39;
         *
         *     var clone = snowLeopard.clone();
         *     alert(Ext.getClassName(clone));             // alerts &#39;My.SnowLeopard&#39;
         *
         * @protected
         */
        self: Base,

        // Default constructor, simply returns `this`
        constructor: function() {
            return this;
        },

        //&lt;feature classSystem.config&gt;

        wasInstantiated: false,

<span id='Ext-Base-method-initConfig'>        /**
</span>         * Initialize configuration for this class. a typical example:
         *
         *     Ext.define(&#39;My.awesome.Class&#39;, {
         *         // The default config
         *         config: {
         *             name: &#39;Awesome&#39;,
         *             isAwesome: true
         *         },
         *
         *         constructor: function(config) {
         *             this.initConfig(config);
         *         }
         *     });
         *
         *     var awesome = new My.awesome.Class({
         *         name: &#39;Super Awesome&#39;
         *     });
         *
         *     alert(awesome.getName()); // &#39;Super Awesome&#39;
         *
         * @protected
         * @param {Object} instanceConfig
         * @return {Object} mixins The mixin prototypes as key - value pairs
         */
        initConfig: function(instanceConfig) {
            //&lt;debug&gt;
//            if (instanceConfig &amp;&amp; instanceConfig.breakOnInitConfig) {
//                debugger;
//            }
            //&lt;/debug&gt;
            var configNameCache = Ext.Class.configNameCache,
                prototype = this.self.prototype,
                initConfigList = this.initConfigList,
                initConfigMap = this.initConfigMap,
                config = new this.configClass,
                defaultConfig = this.defaultConfig,
                i, ln, name, value, nameMap, getName;

            this.initConfig = Ext.emptyFn;

            this.initialConfig = instanceConfig || {};

            if (instanceConfig) {
                Ext.merge(config, instanceConfig);
            }

            this.config = config;

            // Optimize initConfigList *once* per class based on the existence of apply* and update* methods
            // Happens only once during the first instantiation
            if (!prototype.hasOwnProperty(&#39;wasInstantiated&#39;)) {
                prototype.wasInstantiated = true;

                for (i = 0,ln = initConfigList.length; i &lt; ln; i++) {
                    name = initConfigList[i];
                    nameMap = configNameCache[name];
                    value = defaultConfig[name];

                    if (!(nameMap.apply in prototype)
                        &amp;&amp; !(nameMap.update in prototype)
                        &amp;&amp; prototype[nameMap.set].$isDefault
                        &amp;&amp; typeof value != &#39;object&#39;) {
                        prototype[nameMap.internal] = defaultConfig[name];
                        initConfigMap[name] = false;
                        Ext.Array.remove(initConfigList, name);
                        i--;
                        ln--;
                    }
                }
            }

            if (instanceConfig) {
                initConfigList = initConfigList.slice();

                for (name in instanceConfig) {
                    if (name in defaultConfig &amp;&amp; !initConfigMap[name]) {
                        initConfigList.push(name);
                    }
                }
            }

            // Point all getters to the initGetters
            for (i = 0,ln = initConfigList.length; i &lt; ln; i++) {
                name = initConfigList[i];
                nameMap = configNameCache[name];
                this[nameMap.get] = this[nameMap.initGet];
            }

            this.beforeInitConfig(config);

            for (i = 0,ln = initConfigList.length; i &lt; ln; i++) {
                name = initConfigList[i];
                nameMap = configNameCache[name];
                getName = nameMap.get;

                if (this.hasOwnProperty(getName)) {
                    this[nameMap.set].call(this, config[name]);
                    delete this[getName];
                }
            }

            return this;
        },

        beforeInitConfig: Ext.emptyFn,

<span id='Ext-Base-method-getCurrentConfig'>        /**
</span>         * @private
         */
        getCurrentConfig: function() {
            var defaultConfig = this.defaultConfig,
                configNameCache = Ext.Class.configNameCache,
                config = {},
                name, nameMap;

            for (name in defaultConfig) {
                nameMap = configNameCache[name];
                config[name] = this[nameMap.get].call(this);
            }

            return config;
        },

<span id='Ext-Base-method-setConfig'>        /**
</span>         * @private
         */
        setConfig: function(config, applyIfNotSet) {
            if (!config) {
                return this;
            }

            var configNameCache = Ext.Class.configNameCache,
                currentConfig = this.config,
                defaultConfig = this.defaultConfig,
                initialConfig = this.initialConfig,
                configList = [],
                name, i, ln, nameMap;

            applyIfNotSet = Boolean(applyIfNotSet);

            for (name in config) {
                if ((applyIfNotSet &amp;&amp; (name in initialConfig))) {
                    continue;
                }

                currentConfig[name] = config[name];

                if (name in defaultConfig) {
                    configList.push(name);
                    nameMap = configNameCache[name];
                    this[nameMap.get] = this[nameMap.initGet];
                }
            }

            for (i = 0,ln = configList.length; i &lt; ln; i++) {
                name = configList[i];
                nameMap = configNameCache[name];
                this[nameMap.set].call(this, config[name]);
                delete this[nameMap.get];
            }

            return this;
        },

        set: function(name, value) {
            return this[Ext.Class.configNameCache[name].set].call(this, value);
        },

        get: function(name) {
            return this[Ext.Class.configNameCache[name].get].call(this);
        },

<span id='Ext-Base-method-getConfig'>        /**
</span>         * @private
         */
        getConfig: function(name) {
            return this[Ext.Class.configNameCache[name].get].call(this);
        },

<span id='Ext-Base-method-hasConfig'>        /**
</span>         * @private
         */
        hasConfig: function(name) {
            return (name in this.defaultConfig);
        },

<span id='Ext-Base-method-getInitialConfig'>        /**
</span>         * Returns the initial configuration passed to constructor.
         *
         * @param {String} [name] When supplied, value for particular configuration
         * option is returned, otherwise the full config object is returned.
         * @return {Object/Mixed}
         */
        getInitialConfig: function(name) {
            var config = this.config;

            if (!name) {
                return config;
            }
            else {
                return config[name];
            }
        },

<span id='Ext-Base-method-onConfigUpdate'>        /**
</span>         * @private
         */
        onConfigUpdate: function(names, callback, scope) {
            var self = this.self,
                //&lt;debug&gt;
                className = self.$className,
                //&lt;/debug&gt;
                i, ln, name,
                updaterName, updater, newUpdater;

            names = Ext.Array.from(names);

            scope = scope || this;

            for (i = 0,ln = names.length; i &lt; ln; i++) {
                name = names[i];
                updaterName = &#39;update&#39; + Ext.String.capitalize(name);
                updater = this[updaterName] || Ext.emptyFn;
                newUpdater = function() {
                    updater.apply(this, arguments);
                    scope[callback].apply(scope, arguments);
                };
                newUpdater.$name = updaterName;
                newUpdater.$owner = self;
                //&lt;debug&gt;
                newUpdater.displayName = className + &#39;#&#39; + updaterName;
                //&lt;/debug&gt;

                this[updaterName] = newUpdater;
            }
        },
        //&lt;/feature&gt;

<span id='Ext-Base-method-link'>        /**
</span>         * @private
         * @param {String} name
         * @param {Mixed} value
         * @return {Mixed}
         */
        link: function(name, value) {
            this.$links = {};
            this.link = this.doLink;
            return this.link.apply(this, arguments);
        },

        doLink: function(name, value) {
            this.$links[name] = true;

            this[name] = value;

            return value;
        },

<span id='Ext-Base-method-unlink'>        /**
</span>         * @private
         */
        unlink: function() {
            var i, ln, link, value;

            for (i = 0, ln = arguments.length; i &lt; ln; i++) {
                link = arguments[i];
                if (this.hasOwnProperty(link)) {
                    value = this[link];
                    if (value) {
                        if (value.isInstance &amp;&amp; !value.isDestroyed) {
                            value.destroy();
                        }
                        else if (value.parentNode &amp;&amp; &#39;nodeType&#39; in value) {
                            value.parentNode.removeChild(value);
                        }
                    }
                    delete this[link];
                }
            }

            return this;
        },

<span id='Ext-Base-method-destroy'>        /**
</span>         * @protected
         */
        destroy: function() {
            this.destroy = Ext.emptyFn;
            this.isDestroyed = true;

            if (this.hasOwnProperty(&#39;$links&#39;)) {
                this.unlink.apply(this, Ext.Object.getKeys(this.$links));
                delete this.$links;
            }
        }
    });

    Ext.Base = Base;

})(Ext.Function.flexSetter);
</pre>
</body>
</html>
